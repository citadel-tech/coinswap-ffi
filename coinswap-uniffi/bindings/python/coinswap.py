

# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

from __future__ import annotations
import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import threading
import itertools
import traceback
import typing
import platform

# Used for default argument values
_DEFAULT = object() # type: typing.Any


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_uint64),
        ("len", ctypes.c_uint64),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def default():
        return _UniffiRustBuffer(0, 0, None)

    @staticmethod
    def alloc(size):
        return _uniffi_rust_call(_UniffiLib.ffi_coinswap_ffi_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _uniffi_rust_call(_UniffiLib.ffi_coinswap_ffi_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return _uniffi_rust_call(_UniffiLib.ffi_coinswap_ffi_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer at end of consume_with_stream")
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError("junk data left in buffer at end of read_with_stream")

class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_UNEXPECTED_ERROR = 2

    @staticmethod
    def default():
        return _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer.default())

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
            return "_UniffiRustCallStatus(CALL_UNEXPECTED_ERROR)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"

def _uniffi_rust_call(fn, *args):
    # Call a rust function
    return _uniffi_rust_call_with_error(None, fn, *args)

def _uniffi_rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus.default()

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("_uniffi_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
            call_status.code))

def _uniffi_trait_interface_call(call_status, make_call, write_return_value):
    try:
        return write_return_value(make_call())
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))

def _uniffi_trait_interface_call_with_error(call_status, make_call, write_return_value, error_type, lower_error):
    try:
        try:
            return write_return_value(make_call())
        except error_type as e:
            call_status.code = _UniffiRustCallStatus.CALL_ERROR
            call_status.error_buf = lower_error(e)
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))
class _UniffiHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._map = {}  # type: Dict[Handle, Any]
        self._lock = threading.Lock()
        self._counter = itertools.count()

    def insert(self, obj):
        with self._lock:
            handle = next(self._counter)
            self._map[handle] = obj
            return handle

    def get(self, handle):
        try:
            with self._lock:
                return self._map[handle]
        except KeyError:
            raise InternalError("_UniffiHandleMap.get: Invalid handle")

    def remove(self, handle):
        try:
            with self._lock:
                return self._map.pop(handle)
        except KeyError:
            raise InternalError("_UniffiHandleMap.remove: Invalid handle")

    def __len__(self):
        return len(self._map)
# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return value

class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))

class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))

# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)

def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_uint64, return_type, _UniffiRustCallStatus)

def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("coinswap_ffi")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 29
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_coinswap_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def _uniffi_check_api_checksums(lib):
    if lib.uniffi_coinswap_ffi_checksum_func_create_default_rpc_config() != 9423:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_func_fetch_mempool_fees() != 24485:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_func_is_wallet_encrypted() != 41459:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_func_restore_wallet_gui_app() != 58018:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_func_setup_logging() != 49824:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_backup() != 54791:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_display_offer() != 3495:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_do_coinswap() != 30300:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_fetch_all_makers() != 10547:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_fetch_good_makers() != 31706:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_fetch_offers() != 57730:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_get_all_good_makers() != 59201:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_get_balances() != 61330:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_get_next_external_address() != 20757:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_get_next_internal_addresses() != 36525:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_get_transactions() != 59237:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_get_wallet_name() != 45636:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_list_all_utxo_spend_info() != 32425:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_lock_unspendable_utxos() != 12155:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_recover_from_swap() != 45555:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_send_to_address() != 59663:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_sync_and_save() != 9097:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_sync_offerbook() != 23241:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_constructor_taker_init() != 58322:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_int8,
)
_UNIFFI_FOREIGN_FUTURE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
_UNIFFI_CALLBACK_INTERFACE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
class _UniffiForeignFuture(ctypes.Structure):
    _fields_ = [
        ("handle", ctypes.c_uint64),
        ("free", _UNIFFI_FOREIGN_FUTURE_FREE),
    ]
class _UniffiForeignFutureStructU8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU8,
)
class _UniffiForeignFutureStructI8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI8,
)
class _UniffiForeignFutureStructU16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU16,
)
class _UniffiForeignFutureStructI16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI16,
)
class _UniffiForeignFutureStructU32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU32,
)
class _UniffiForeignFutureStructI32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI32,
)
class _UniffiForeignFutureStructU64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU64,
)
class _UniffiForeignFutureStructI64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI64,
)
class _UniffiForeignFutureStructF32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_float),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF32,
)
class _UniffiForeignFutureStructF64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_double),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF64,
)
class _UniffiForeignFutureStructPointer(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_void_p),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_POINTER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructPointer,
)
class _UniffiForeignFutureStructRustBuffer(ctypes.Structure):
    _fields_ = [
        ("return_value", _UniffiRustBuffer),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructRustBuffer,
)
class _UniffiForeignFutureStructVoid(ctypes.Structure):
    _fields_ = [
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructVoid,
)
_UniffiLib.uniffi_coinswap_ffi_fn_clone_taker.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_clone_taker.restype = ctypes.c_void_p
_UniffiLib.uniffi_coinswap_ffi_fn_free_taker.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_free_taker.restype = None
_UniffiLib.uniffi_coinswap_ffi_fn_constructor_taker_init.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_constructor_taker_init.restype = ctypes.c_void_p
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_backup.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_backup.restype = None
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_display_offer.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_display_offer.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_do_coinswap.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_do_coinswap.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_fetch_all_makers.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_fetch_all_makers.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_fetch_good_makers.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_fetch_good_makers.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_fetch_offers.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_fetch_offers.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_get_all_good_makers.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_get_all_good_makers.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_get_balances.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_get_balances.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_get_next_external_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_get_next_external_address.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_get_next_internal_addresses.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_get_next_internal_addresses.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_get_transactions.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_get_transactions.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_get_wallet_name.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_get_wallet_name.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_list_all_utxo_spend_info.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_list_all_utxo_spend_info.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_lock_unspendable_utxos.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_lock_unspendable_utxos.restype = None
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_recover_from_swap.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_recover_from_swap.restype = None
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_send_to_address.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_int64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_send_to_address.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_sync_and_save.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_sync_and_save.restype = None
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_sync_offerbook.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_sync_offerbook.restype = None
_UniffiLib.uniffi_coinswap_ffi_fn_func_create_default_rpc_config.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_func_create_default_rpc_config.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_func_fetch_mempool_fees.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_func_fetch_mempool_fees.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_func_is_wallet_encrypted.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_func_is_wallet_encrypted.restype = ctypes.c_int8
_UniffiLib.uniffi_coinswap_ffi_fn_func_restore_wallet_gui_app.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_func_restore_wallet_gui_app.restype = None
_UniffiLib.uniffi_coinswap_ffi_fn_func_setup_logging.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_func_setup_logging.restype = None
_UniffiLib.ffi_coinswap_ffi_rustbuffer_alloc.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_coinswap_ffi_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_coinswap_ffi_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_coinswap_ffi_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_coinswap_ffi_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_coinswap_ffi_rustbuffer_free.restype = None
_UniffiLib.ffi_coinswap_ffi_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_coinswap_ffi_rustbuffer_reserve.restype = _UniffiRustBuffer
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_u8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_u8.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_free_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_free_u8.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_u8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_u8.restype = ctypes.c_uint8
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_i8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_i8.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_free_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_free_i8.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_i8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_i8.restype = ctypes.c_int8
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_u16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_u16.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_free_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_free_u16.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_u16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_u16.restype = ctypes.c_uint16
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_i16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_i16.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_free_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_free_i16.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_i16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_i16.restype = ctypes.c_int16
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_u32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_u32.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_free_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_free_u32.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_u32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_u32.restype = ctypes.c_uint32
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_i32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_i32.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_free_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_free_i32.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_i32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_i32.restype = ctypes.c_int32
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_u64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_u64.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_free_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_free_u64.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_u64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_u64.restype = ctypes.c_uint64
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_i64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_i64.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_free_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_free_i64.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_i64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_i64.restype = ctypes.c_int64
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_f32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_f32.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_free_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_free_f32.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_f32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_f32.restype = ctypes.c_float
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_f64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_f64.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_free_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_free_f64.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_f64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_f64.restype = ctypes.c_double
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_pointer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_pointer.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_pointer.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_free_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_free_pointer.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_pointer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_pointer.restype = ctypes.c_void_p
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_free_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_rust_buffer.restype = _UniffiRustBuffer
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_void.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_void.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_void.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_free_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_free_void.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_void.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_void.restype = None
_UniffiLib.uniffi_coinswap_ffi_checksum_func_create_default_rpc_config.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_func_create_default_rpc_config.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_func_fetch_mempool_fees.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_func_fetch_mempool_fees.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_func_is_wallet_encrypted.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_func_is_wallet_encrypted.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_func_restore_wallet_gui_app.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_func_restore_wallet_gui_app.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_func_setup_logging.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_func_setup_logging.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_backup.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_backup.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_display_offer.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_display_offer.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_do_coinswap.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_do_coinswap.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_fetch_all_makers.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_fetch_all_makers.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_fetch_good_makers.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_fetch_good_makers.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_fetch_offers.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_fetch_offers.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_get_all_good_makers.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_get_all_good_makers.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_get_balances.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_get_balances.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_get_next_external_address.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_get_next_external_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_get_next_internal_addresses.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_get_next_internal_addresses.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_get_transactions.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_get_transactions.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_get_wallet_name.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_get_wallet_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_list_all_utxo_spend_info.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_list_all_utxo_spend_info.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_lock_unspendable_utxos.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_lock_unspendable_utxos.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_recover_from_swap.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_recover_from_swap.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_send_to_address.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_send_to_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_sync_and_save.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_sync_and_save.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_sync_offerbook.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_sync_offerbook.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_constructor_taker_init.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_constructor_taker_init.restype = ctypes.c_uint16
_UniffiLib.ffi_coinswap_ffi_uniffi_contract_version.argtypes = (
)
_UniffiLib.ffi_coinswap_ffi_uniffi_contract_version.restype = ctypes.c_uint32

_uniffi_check_contract_api_version(_UniffiLib)
# _uniffi_check_api_checksums(_UniffiLib)

# Public interface members begin here.


class _UniffiConverterUInt16(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u16"
    VALUE_MIN = 0
    VALUE_MAX = 2**16

    @staticmethod
    def read(buf):
        return buf.read_u16()

    @staticmethod
    def write(value, buf):
        buf.write_u16(value)

class _UniffiConverterUInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u32"
    VALUE_MIN = 0
    VALUE_MAX = 2**32

    @staticmethod
    def read(buf):
        return buf.read_u32()

    @staticmethod
    def write(value, buf):
        buf.write_u32(value)

class _UniffiConverterInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i32"
    VALUE_MIN = -2**31
    VALUE_MAX = 2**31

    @staticmethod
    def read(buf):
        return buf.read_i32()

    @staticmethod
    def write(value, buf):
        buf.write_i32(value)

class _UniffiConverterUInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u64"
    VALUE_MIN = 0
    VALUE_MAX = 2**64

    @staticmethod
    def read(buf):
        return buf.read_u64()

    @staticmethod
    def write(value, buf):
        buf.write_u64(value)

class _UniffiConverterInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i64"
    VALUE_MIN = -2**63
    VALUE_MAX = 2**63

    @staticmethod
    def read(buf):
        return buf.read_i64()

    @staticmethod
    def write(value, buf):
        buf.write_i64(value)

class _UniffiConverterDouble(_UniffiConverterPrimitiveFloat):
    @staticmethod
    def read(buf):
        return buf.read_double()

    @staticmethod
    def write(value, buf):
        buf.write_double(value)

class _UniffiConverterBool:
    @classmethod
    def check_lower(cls, value):
        return not not value

    @classmethod
    def lower(cls, value):
        return 1 if value else 0

    @staticmethod
    def lift(value):
        return value != 0

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write(cls, value, buf):
        buf.write_u8(value)

class _UniffiConverterString:
    @staticmethod
    def check_lower(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()

class _UniffiConverterBytes(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative byte string length")
        return buf.read(size)

    @staticmethod
    def check_lower(value):
        try:
            memoryview(value)
        except TypeError:
            raise TypeError("a bytes-like object is required, not {!r}".format(type(value).__name__))

    @staticmethod
    def write(value, buf):
        buf.write_i32(len(value))
        buf.write(value)




class Address:
    address: "str"
    def __init__(self, *, address: "str"):
        self.address = address

    def __str__(self):
        return "Address(address={})".format(self.address)

    def __eq__(self, other):
        if self.address != other.address:
            return False
        return True

class _UniffiConverterTypeAddress(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Address(
            address=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.address)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.address, buf)


class Amount:
    sats: "int"
    def __init__(self, *, sats: "int"):
        self.sats = sats

    def __str__(self):
        return "Amount(sats={})".format(self.sats)

    def __eq__(self, other):
        if self.sats != other.sats:
            return False
        return True

class _UniffiConverterTypeAmount(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Amount(
            sats=_UniffiConverterInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterInt64.check_lower(value.sats)

    @staticmethod
    def write(value, buf):
        _UniffiConverterInt64.write(value.sats, buf)


class Balances:
    regular: "int"
    swap: "int"
    contract: "int"
    fidelity: "int"
    spendable: "int"
    def __init__(self, *, regular: "int", swap: "int", contract: "int", fidelity: "int", spendable: "int"):
        self.regular = regular
        self.swap = swap
        self.contract = contract
        self.fidelity = fidelity
        self.spendable = spendable

    def __str__(self):
        return "Balances(regular={}, swap={}, contract={}, fidelity={}, spendable={})".format(self.regular, self.swap, self.contract, self.fidelity, self.spendable)

    def __eq__(self, other):
        if self.regular != other.regular:
            return False
        if self.swap != other.swap:
            return False
        if self.contract != other.contract:
            return False
        if self.fidelity != other.fidelity:
            return False
        if self.spendable != other.spendable:
            return False
        return True

class _UniffiConverterTypeBalances(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Balances(
            regular=_UniffiConverterInt64.read(buf),
            swap=_UniffiConverterInt64.read(buf),
            contract=_UniffiConverterInt64.read(buf),
            fidelity=_UniffiConverterInt64.read(buf),
            spendable=_UniffiConverterInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterInt64.check_lower(value.regular)
        _UniffiConverterInt64.check_lower(value.swap)
        _UniffiConverterInt64.check_lower(value.contract)
        _UniffiConverterInt64.check_lower(value.fidelity)
        _UniffiConverterInt64.check_lower(value.spendable)

    @staticmethod
    def write(value, buf):
        _UniffiConverterInt64.write(value.regular, buf)
        _UniffiConverterInt64.write(value.swap, buf)
        _UniffiConverterInt64.write(value.contract, buf)
        _UniffiConverterInt64.write(value.fidelity, buf)
        _UniffiConverterInt64.write(value.spendable, buf)


class FeeRates:
    fastest: "float"
    standard: "float"
    economy: "float"
    def __init__(self, *, fastest: "float", standard: "float", economy: "float"):
        self.fastest = fastest
        self.standard = standard
        self.economy = economy

    def __str__(self):
        return "FeeRates(fastest={}, standard={}, economy={})".format(self.fastest, self.standard, self.economy)

    def __eq__(self, other):
        if self.fastest != other.fastest:
            return False
        if self.standard != other.standard:
            return False
        if self.economy != other.economy:
            return False
        return True

class _UniffiConverterTypeFeeRates(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FeeRates(
            fastest=_UniffiConverterDouble.read(buf),
            standard=_UniffiConverterDouble.read(buf),
            economy=_UniffiConverterDouble.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterDouble.check_lower(value.fastest)
        _UniffiConverterDouble.check_lower(value.standard)
        _UniffiConverterDouble.check_lower(value.economy)

    @staticmethod
    def write(value, buf):
        _UniffiConverterDouble.write(value.fastest, buf)
        _UniffiConverterDouble.write(value.standard, buf)
        _UniffiConverterDouble.write(value.economy, buf)


class FidelityBond:
    amount: "Amount"
    lock_time: "LockTime"
    pubkey: "PublicKey"
    def __init__(self, *, amount: "Amount", lock_time: "LockTime", pubkey: "PublicKey"):
        self.amount = amount
        self.lock_time = lock_time
        self.pubkey = pubkey

    def __str__(self):
        return "FidelityBond(amount={}, lock_time={}, pubkey={})".format(self.amount, self.lock_time, self.pubkey)

    def __eq__(self, other):
        if self.amount != other.amount:
            return False
        if self.lock_time != other.lock_time:
            return False
        if self.pubkey != other.pubkey:
            return False
        return True

class _UniffiConverterTypeFidelityBond(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FidelityBond(
            amount=_UniffiConverterTypeAmount.read(buf),
            lock_time=_UniffiConverterTypeLockTime.read(buf),
            pubkey=_UniffiConverterTypePublicKey.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeAmount.check_lower(value.amount)
        _UniffiConverterTypeLockTime.check_lower(value.lock_time)
        _UniffiConverterTypePublicKey.check_lower(value.pubkey)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAmount.write(value.amount, buf)
        _UniffiConverterTypeLockTime.write(value.lock_time, buf)
        _UniffiConverterTypePublicKey.write(value.pubkey, buf)


class FidelityProof:
    bond: "FidelityBond"
    cert_hash: "bytes"
    cert_sig: "bytes"
    def __init__(self, *, bond: "FidelityBond", cert_hash: "bytes", cert_sig: "bytes"):
        self.bond = bond
        self.cert_hash = cert_hash
        self.cert_sig = cert_sig

    def __str__(self):
        return "FidelityProof(bond={}, cert_hash={}, cert_sig={})".format(self.bond, self.cert_hash, self.cert_sig)

    def __eq__(self, other):
        if self.bond != other.bond:
            return False
        if self.cert_hash != other.cert_hash:
            return False
        if self.cert_sig != other.cert_sig:
            return False
        return True

class _UniffiConverterTypeFidelityProof(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FidelityProof(
            bond=_UniffiConverterTypeFidelityBond.read(buf),
            cert_hash=_UniffiConverterBytes.read(buf),
            cert_sig=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeFidelityBond.check_lower(value.bond)
        _UniffiConverterBytes.check_lower(value.cert_hash)
        _UniffiConverterBytes.check_lower(value.cert_sig)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeFidelityBond.write(value.bond, buf)
        _UniffiConverterBytes.write(value.cert_hash, buf)
        _UniffiConverterBytes.write(value.cert_sig, buf)


class GetTransactionResultDetail:
    address: "typing.Optional[Address]"
    category: "str"
    amount: "SignedAmountSats"
    label: "typing.Optional[str]"
    vout: "int"
    fee: "typing.Optional[SignedAmountSats]"
    abandoned: "typing.Optional[bool]"
    def __init__(self, *, address: "typing.Optional[Address]", category: "str", amount: "SignedAmountSats", label: "typing.Optional[str]", vout: "int", fee: "typing.Optional[SignedAmountSats]", abandoned: "typing.Optional[bool]"):
        self.address = address
        self.category = category
        self.amount = amount
        self.label = label
        self.vout = vout
        self.fee = fee
        self.abandoned = abandoned

    def __str__(self):
        return "GetTransactionResultDetail(address={}, category={}, amount={}, label={}, vout={}, fee={}, abandoned={})".format(self.address, self.category, self.amount, self.label, self.vout, self.fee, self.abandoned)

    def __eq__(self, other):
        if self.address != other.address:
            return False
        if self.category != other.category:
            return False
        if self.amount != other.amount:
            return False
        if self.label != other.label:
            return False
        if self.vout != other.vout:
            return False
        if self.fee != other.fee:
            return False
        if self.abandoned != other.abandoned:
            return False
        return True

class _UniffiConverterTypeGetTransactionResultDetail(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GetTransactionResultDetail(
            address=_UniffiConverterOptionalTypeAddress.read(buf),
            category=_UniffiConverterString.read(buf),
            amount=_UniffiConverterTypeSignedAmountSats.read(buf),
            label=_UniffiConverterOptionalString.read(buf),
            vout=_UniffiConverterUInt32.read(buf),
            fee=_UniffiConverterOptionalTypeSignedAmountSats.read(buf),
            abandoned=_UniffiConverterOptionalBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalTypeAddress.check_lower(value.address)
        _UniffiConverterString.check_lower(value.category)
        _UniffiConverterTypeSignedAmountSats.check_lower(value.amount)
        _UniffiConverterOptionalString.check_lower(value.label)
        _UniffiConverterUInt32.check_lower(value.vout)
        _UniffiConverterOptionalTypeSignedAmountSats.check_lower(value.fee)
        _UniffiConverterOptionalBool.check_lower(value.abandoned)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeAddress.write(value.address, buf)
        _UniffiConverterString.write(value.category, buf)
        _UniffiConverterTypeSignedAmountSats.write(value.amount, buf)
        _UniffiConverterOptionalString.write(value.label, buf)
        _UniffiConverterUInt32.write(value.vout, buf)
        _UniffiConverterOptionalTypeSignedAmountSats.write(value.fee, buf)
        _UniffiConverterOptionalBool.write(value.abandoned, buf)


class ListTransactionResult:
    info: "WalletTxInfo"
    detail: "GetTransactionResultDetail"
    trusted: "typing.Optional[bool]"
    comment: "typing.Optional[str]"
    def __init__(self, *, info: "WalletTxInfo", detail: "GetTransactionResultDetail", trusted: "typing.Optional[bool]", comment: "typing.Optional[str]"):
        self.info = info
        self.detail = detail
        self.trusted = trusted
        self.comment = comment

    def __str__(self):
        return "ListTransactionResult(info={}, detail={}, trusted={}, comment={})".format(self.info, self.detail, self.trusted, self.comment)

    def __eq__(self, other):
        if self.info != other.info:
            return False
        if self.detail != other.detail:
            return False
        if self.trusted != other.trusted:
            return False
        if self.comment != other.comment:
            return False
        return True

class _UniffiConverterTypeListTransactionResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ListTransactionResult(
            info=_UniffiConverterTypeWalletTxInfo.read(buf),
            detail=_UniffiConverterTypeGetTransactionResultDetail.read(buf),
            trusted=_UniffiConverterOptionalBool.read(buf),
            comment=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeWalletTxInfo.check_lower(value.info)
        _UniffiConverterTypeGetTransactionResultDetail.check_lower(value.detail)
        _UniffiConverterOptionalBool.check_lower(value.trusted)
        _UniffiConverterOptionalString.check_lower(value.comment)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeWalletTxInfo.write(value.info, buf)
        _UniffiConverterTypeGetTransactionResultDetail.write(value.detail, buf)
        _UniffiConverterOptionalBool.write(value.trusted, buf)
        _UniffiConverterOptionalString.write(value.comment, buf)


class ListUnspentResultEntry:
    txid: "Txid"
    vout: "int"
    address: "typing.Optional[str]"
    label: "typing.Optional[str]"
    script_pub_key: "ScriptBuf"
    amount: "Amount"
    confirmations: "int"
    redeem_script: "typing.Optional[ScriptBuf]"
    witness_script: "typing.Optional[ScriptBuf]"
    spendable: "bool"
    solvable: "bool"
    desc: "typing.Optional[str]"
    safe: "bool"
    def __init__(self, *, txid: "Txid", vout: "int", address: "typing.Optional[str]", label: "typing.Optional[str]", script_pub_key: "ScriptBuf", amount: "Amount", confirmations: "int", redeem_script: "typing.Optional[ScriptBuf]", witness_script: "typing.Optional[ScriptBuf]", spendable: "bool", solvable: "bool", desc: "typing.Optional[str]", safe: "bool"):
        self.txid = txid
        self.vout = vout
        self.address = address
        self.label = label
        self.script_pub_key = script_pub_key
        self.amount = amount
        self.confirmations = confirmations
        self.redeem_script = redeem_script
        self.witness_script = witness_script
        self.spendable = spendable
        self.solvable = solvable
        self.desc = desc
        self.safe = safe

    def __str__(self):
        return "ListUnspentResultEntry(txid={}, vout={}, address={}, label={}, script_pub_key={}, amount={}, confirmations={}, redeem_script={}, witness_script={}, spendable={}, solvable={}, desc={}, safe={})".format(self.txid, self.vout, self.address, self.label, self.script_pub_key, self.amount, self.confirmations, self.redeem_script, self.witness_script, self.spendable, self.solvable, self.desc, self.safe)

    def __eq__(self, other):
        if self.txid != other.txid:
            return False
        if self.vout != other.vout:
            return False
        if self.address != other.address:
            return False
        if self.label != other.label:
            return False
        if self.script_pub_key != other.script_pub_key:
            return False
        if self.amount != other.amount:
            return False
        if self.confirmations != other.confirmations:
            return False
        if self.redeem_script != other.redeem_script:
            return False
        if self.witness_script != other.witness_script:
            return False
        if self.spendable != other.spendable:
            return False
        if self.solvable != other.solvable:
            return False
        if self.desc != other.desc:
            return False
        if self.safe != other.safe:
            return False
        return True

class _UniffiConverterTypeListUnspentResultEntry(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ListUnspentResultEntry(
            txid=_UniffiConverterTypeTxid.read(buf),
            vout=_UniffiConverterUInt32.read(buf),
            address=_UniffiConverterOptionalString.read(buf),
            label=_UniffiConverterOptionalString.read(buf),
            script_pub_key=_UniffiConverterTypeScriptBuf.read(buf),
            amount=_UniffiConverterTypeAmount.read(buf),
            confirmations=_UniffiConverterUInt32.read(buf),
            redeem_script=_UniffiConverterOptionalTypeScriptBuf.read(buf),
            witness_script=_UniffiConverterOptionalTypeScriptBuf.read(buf),
            spendable=_UniffiConverterBool.read(buf),
            solvable=_UniffiConverterBool.read(buf),
            desc=_UniffiConverterOptionalString.read(buf),
            safe=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeTxid.check_lower(value.txid)
        _UniffiConverterUInt32.check_lower(value.vout)
        _UniffiConverterOptionalString.check_lower(value.address)
        _UniffiConverterOptionalString.check_lower(value.label)
        _UniffiConverterTypeScriptBuf.check_lower(value.script_pub_key)
        _UniffiConverterTypeAmount.check_lower(value.amount)
        _UniffiConverterUInt32.check_lower(value.confirmations)
        _UniffiConverterOptionalTypeScriptBuf.check_lower(value.redeem_script)
        _UniffiConverterOptionalTypeScriptBuf.check_lower(value.witness_script)
        _UniffiConverterBool.check_lower(value.spendable)
        _UniffiConverterBool.check_lower(value.solvable)
        _UniffiConverterOptionalString.check_lower(value.desc)
        _UniffiConverterBool.check_lower(value.safe)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeTxid.write(value.txid, buf)
        _UniffiConverterUInt32.write(value.vout, buf)
        _UniffiConverterOptionalString.write(value.address, buf)
        _UniffiConverterOptionalString.write(value.label, buf)
        _UniffiConverterTypeScriptBuf.write(value.script_pub_key, buf)
        _UniffiConverterTypeAmount.write(value.amount, buf)
        _UniffiConverterUInt32.write(value.confirmations, buf)
        _UniffiConverterOptionalTypeScriptBuf.write(value.redeem_script, buf)
        _UniffiConverterOptionalTypeScriptBuf.write(value.witness_script, buf)
        _UniffiConverterBool.write(value.spendable, buf)
        _UniffiConverterBool.write(value.solvable, buf)
        _UniffiConverterOptionalString.write(value.desc, buf)
        _UniffiConverterBool.write(value.safe, buf)


class LockTime:
    lock_type: "str"
    value: "int"
    def __init__(self, *, lock_type: "str", value: "int"):
        self.lock_type = lock_type
        self.value = value

    def __str__(self):
        return "LockTime(lock_type={}, value={})".format(self.lock_type, self.value)

    def __eq__(self, other):
        if self.lock_type != other.lock_type:
            return False
        if self.value != other.value:
            return False
        return True

class _UniffiConverterTypeLockTime(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LockTime(
            lock_type=_UniffiConverterString.read(buf),
            value=_UniffiConverterUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.lock_type)
        _UniffiConverterUInt32.check_lower(value.value)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.lock_type, buf)
        _UniffiConverterUInt32.write(value.value, buf)


class MakerAddress:
    address: "str"
    def __init__(self, *, address: "str"):
        self.address = address

    def __str__(self):
        return "MakerAddress(address={})".format(self.address)

    def __eq__(self, other):
        if self.address != other.address:
            return False
        return True

class _UniffiConverterTypeMakerAddress(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MakerAddress(
            address=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.address)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.address, buf)


class MakerFeeInfo:
    maker_index: "int"
    maker_address: "str"
    base_fee: "float"
    amount_relative_fee: "float"
    time_relative_fee: "float"
    total_fee: "float"
    def __init__(self, *, maker_index: "int", maker_address: "str", base_fee: "float", amount_relative_fee: "float", time_relative_fee: "float", total_fee: "float"):
        self.maker_index = maker_index
        self.maker_address = maker_address
        self.base_fee = base_fee
        self.amount_relative_fee = amount_relative_fee
        self.time_relative_fee = time_relative_fee
        self.total_fee = total_fee

    def __str__(self):
        return "MakerFeeInfo(maker_index={}, maker_address={}, base_fee={}, amount_relative_fee={}, time_relative_fee={}, total_fee={})".format(self.maker_index, self.maker_address, self.base_fee, self.amount_relative_fee, self.time_relative_fee, self.total_fee)

    def __eq__(self, other):
        if self.maker_index != other.maker_index:
            return False
        if self.maker_address != other.maker_address:
            return False
        if self.base_fee != other.base_fee:
            return False
        if self.amount_relative_fee != other.amount_relative_fee:
            return False
        if self.time_relative_fee != other.time_relative_fee:
            return False
        if self.total_fee != other.total_fee:
            return False
        return True

class _UniffiConverterTypeMakerFeeInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MakerFeeInfo(
            maker_index=_UniffiConverterUInt32.read(buf),
            maker_address=_UniffiConverterString.read(buf),
            base_fee=_UniffiConverterDouble.read(buf),
            amount_relative_fee=_UniffiConverterDouble.read(buf),
            time_relative_fee=_UniffiConverterDouble.read(buf),
            total_fee=_UniffiConverterDouble.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt32.check_lower(value.maker_index)
        _UniffiConverterString.check_lower(value.maker_address)
        _UniffiConverterDouble.check_lower(value.base_fee)
        _UniffiConverterDouble.check_lower(value.amount_relative_fee)
        _UniffiConverterDouble.check_lower(value.time_relative_fee)
        _UniffiConverterDouble.check_lower(value.total_fee)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt32.write(value.maker_index, buf)
        _UniffiConverterString.write(value.maker_address, buf)
        _UniffiConverterDouble.write(value.base_fee, buf)
        _UniffiConverterDouble.write(value.amount_relative_fee, buf)
        _UniffiConverterDouble.write(value.time_relative_fee, buf)
        _UniffiConverterDouble.write(value.total_fee, buf)


class Offer:
    base_fee: "int"
    amount_relative_fee_pct: "float"
    time_relative_fee_pct: "float"
    required_confirms: "int"
    minimum_locktime: "int"
    max_size: "int"
    min_size: "int"
    tweakable_point: "PublicKey"
    fidelity: "FidelityProof"
    def __init__(self, *, base_fee: "int", amount_relative_fee_pct: "float", time_relative_fee_pct: "float", required_confirms: "int", minimum_locktime: "int", max_size: "int", min_size: "int", tweakable_point: "PublicKey", fidelity: "FidelityProof"):
        self.base_fee = base_fee
        self.amount_relative_fee_pct = amount_relative_fee_pct
        self.time_relative_fee_pct = time_relative_fee_pct
        self.required_confirms = required_confirms
        self.minimum_locktime = minimum_locktime
        self.max_size = max_size
        self.min_size = min_size
        self.tweakable_point = tweakable_point
        self.fidelity = fidelity

    def __str__(self):
        return "Offer(base_fee={}, amount_relative_fee_pct={}, time_relative_fee_pct={}, required_confirms={}, minimum_locktime={}, max_size={}, min_size={}, tweakable_point={}, fidelity={})".format(self.base_fee, self.amount_relative_fee_pct, self.time_relative_fee_pct, self.required_confirms, self.minimum_locktime, self.max_size, self.min_size, self.tweakable_point, self.fidelity)

    def __eq__(self, other):
        if self.base_fee != other.base_fee:
            return False
        if self.amount_relative_fee_pct != other.amount_relative_fee_pct:
            return False
        if self.time_relative_fee_pct != other.time_relative_fee_pct:
            return False
        if self.required_confirms != other.required_confirms:
            return False
        if self.minimum_locktime != other.minimum_locktime:
            return False
        if self.max_size != other.max_size:
            return False
        if self.min_size != other.min_size:
            return False
        if self.tweakable_point != other.tweakable_point:
            return False
        if self.fidelity != other.fidelity:
            return False
        return True

class _UniffiConverterTypeOffer(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Offer(
            base_fee=_UniffiConverterInt64.read(buf),
            amount_relative_fee_pct=_UniffiConverterDouble.read(buf),
            time_relative_fee_pct=_UniffiConverterDouble.read(buf),
            required_confirms=_UniffiConverterUInt32.read(buf),
            minimum_locktime=_UniffiConverterUInt16.read(buf),
            max_size=_UniffiConverterInt64.read(buf),
            min_size=_UniffiConverterInt64.read(buf),
            tweakable_point=_UniffiConverterTypePublicKey.read(buf),
            fidelity=_UniffiConverterTypeFidelityProof.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterInt64.check_lower(value.base_fee)
        _UniffiConverterDouble.check_lower(value.amount_relative_fee_pct)
        _UniffiConverterDouble.check_lower(value.time_relative_fee_pct)
        _UniffiConverterUInt32.check_lower(value.required_confirms)
        _UniffiConverterUInt16.check_lower(value.minimum_locktime)
        _UniffiConverterInt64.check_lower(value.max_size)
        _UniffiConverterInt64.check_lower(value.min_size)
        _UniffiConverterTypePublicKey.check_lower(value.tweakable_point)
        _UniffiConverterTypeFidelityProof.check_lower(value.fidelity)

    @staticmethod
    def write(value, buf):
        _UniffiConverterInt64.write(value.base_fee, buf)
        _UniffiConverterDouble.write(value.amount_relative_fee_pct, buf)
        _UniffiConverterDouble.write(value.time_relative_fee_pct, buf)
        _UniffiConverterUInt32.write(value.required_confirms, buf)
        _UniffiConverterUInt16.write(value.minimum_locktime, buf)
        _UniffiConverterInt64.write(value.max_size, buf)
        _UniffiConverterInt64.write(value.min_size, buf)
        _UniffiConverterTypePublicKey.write(value.tweakable_point, buf)
        _UniffiConverterTypeFidelityProof.write(value.fidelity, buf)


class OfferAndAddress:
    offer: "Offer"
    address: "MakerAddress"
    def __init__(self, *, offer: "Offer", address: "MakerAddress"):
        self.offer = offer
        self.address = address

    def __str__(self):
        return "OfferAndAddress(offer={}, address={})".format(self.offer, self.address)

    def __eq__(self, other):
        if self.offer != other.offer:
            return False
        if self.address != other.address:
            return False
        return True

class _UniffiConverterTypeOfferAndAddress(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OfferAndAddress(
            offer=_UniffiConverterTypeOffer.read(buf),
            address=_UniffiConverterTypeMakerAddress.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeOffer.check_lower(value.offer)
        _UniffiConverterTypeMakerAddress.check_lower(value.address)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeOffer.write(value.offer, buf)
        _UniffiConverterTypeMakerAddress.write(value.address, buf)


class OfferBook:
    good_makers: "typing.List[OfferAndAddress]"
    all_makers: "typing.List[OfferAndAddress]"
    def __init__(self, *, good_makers: "typing.List[OfferAndAddress]", all_makers: "typing.List[OfferAndAddress]"):
        self.good_makers = good_makers
        self.all_makers = all_makers

    def __str__(self):
        return "OfferBook(good_makers={}, all_makers={})".format(self.good_makers, self.all_makers)

    def __eq__(self, other):
        if self.good_makers != other.good_makers:
            return False
        if self.all_makers != other.all_makers:
            return False
        return True

class _UniffiConverterTypeOfferBook(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OfferBook(
            good_makers=_UniffiConverterSequenceTypeOfferAndAddress.read(buf),
            all_makers=_UniffiConverterSequenceTypeOfferAndAddress.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeOfferAndAddress.check_lower(value.good_makers)
        _UniffiConverterSequenceTypeOfferAndAddress.check_lower(value.all_makers)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeOfferAndAddress.write(value.good_makers, buf)
        _UniffiConverterSequenceTypeOfferAndAddress.write(value.all_makers, buf)


class OutPoint:
    txid: "Txid"
    vout: "int"
    def __init__(self, *, txid: "Txid", vout: "int"):
        self.txid = txid
        self.vout = vout

    def __str__(self):
        return "OutPoint(txid={}, vout={})".format(self.txid, self.vout)

    def __eq__(self, other):
        if self.txid != other.txid:
            return False
        if self.vout != other.vout:
            return False
        return True

class _UniffiConverterTypeOutPoint(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OutPoint(
            txid=_UniffiConverterTypeTxid.read(buf),
            vout=_UniffiConverterUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeTxid.check_lower(value.txid)
        _UniffiConverterUInt32.check_lower(value.vout)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeTxid.write(value.txid, buf)
        _UniffiConverterUInt32.write(value.vout, buf)


class PublicKey:
    compressed: "bool"
    inner: "bytes"
    def __init__(self, *, compressed: "bool", inner: "bytes"):
        self.compressed = compressed
        self.inner = inner

    def __str__(self):
        return "PublicKey(compressed={}, inner={})".format(self.compressed, self.inner)

    def __eq__(self, other):
        if self.compressed != other.compressed:
            return False
        if self.inner != other.inner:
            return False
        return True

class _UniffiConverterTypePublicKey(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PublicKey(
            compressed=_UniffiConverterBool.read(buf),
            inner=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBool.check_lower(value.compressed)
        _UniffiConverterBytes.check_lower(value.inner)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.compressed, buf)
        _UniffiConverterBytes.write(value.inner, buf)


class RpcConfig:
    url: "str"
    username: "str"
    password: "str"
    wallet_name: "str"
    def __init__(self, *, url: "str", username: "str", password: "str", wallet_name: "str"):
        self.url = url
        self.username = username
        self.password = password
        self.wallet_name = wallet_name

    def __str__(self):
        return "RpcConfig(url={}, username={}, password={}, wallet_name={})".format(self.url, self.username, self.password, self.wallet_name)

    def __eq__(self, other):
        if self.url != other.url:
            return False
        if self.username != other.username:
            return False
        if self.password != other.password:
            return False
        if self.wallet_name != other.wallet_name:
            return False
        return True

class _UniffiConverterTypeRpcConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RpcConfig(
            url=_UniffiConverterString.read(buf),
            username=_UniffiConverterString.read(buf),
            password=_UniffiConverterString.read(buf),
            wallet_name=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.url)
        _UniffiConverterString.check_lower(value.username)
        _UniffiConverterString.check_lower(value.password)
        _UniffiConverterString.check_lower(value.wallet_name)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.url, buf)
        _UniffiConverterString.write(value.username, buf)
        _UniffiConverterString.write(value.password, buf)
        _UniffiConverterString.write(value.wallet_name, buf)


class ScriptBuf:
    hex: "str"
    def __init__(self, *, hex: "str"):
        self.hex = hex

    def __str__(self):
        return "ScriptBuf(hex={})".format(self.hex)

    def __eq__(self, other):
        if self.hex != other.hex:
            return False
        return True

class _UniffiConverterTypeScriptBuf(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ScriptBuf(
            hex=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.hex)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.hex, buf)


class SignedAmountSats:
    sats: "int"
    def __init__(self, *, sats: "int"):
        self.sats = sats

    def __str__(self):
        return "SignedAmountSats(sats={})".format(self.sats)

    def __eq__(self, other):
        if self.sats != other.sats:
            return False
        return True

class _UniffiConverterTypeSignedAmountSats(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SignedAmountSats(
            sats=_UniffiConverterInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterInt64.check_lower(value.sats)

    @staticmethod
    def write(value, buf):
        _UniffiConverterInt64.write(value.sats, buf)


class SwapParams:
    send_amount: "int"
    """
    Total Amount
    """

    maker_count: "int"
    """
    How many hops (number of makers)
    """

    manually_selected_outpoints: "typing.Optional[typing.List[OutPoint]]"
    """
    User selected UTXOs (optional)
    """

    def __init__(self, *, send_amount: "int", maker_count: "int", manually_selected_outpoints: "typing.Optional[typing.List[OutPoint]]"):
        self.send_amount = send_amount
        self.maker_count = maker_count
        self.manually_selected_outpoints = manually_selected_outpoints

    def __str__(self):
        return "SwapParams(send_amount={}, maker_count={}, manually_selected_outpoints={})".format(self.send_amount, self.maker_count, self.manually_selected_outpoints)

    def __eq__(self, other):
        if self.send_amount != other.send_amount:
            return False
        if self.maker_count != other.maker_count:
            return False
        if self.manually_selected_outpoints != other.manually_selected_outpoints:
            return False
        return True

class _UniffiConverterTypeSwapParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SwapParams(
            send_amount=_UniffiConverterUInt64.read(buf),
            maker_count=_UniffiConverterUInt32.read(buf),
            manually_selected_outpoints=_UniffiConverterOptionalSequenceTypeOutPoint.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.send_amount)
        _UniffiConverterUInt32.check_lower(value.maker_count)
        _UniffiConverterOptionalSequenceTypeOutPoint.check_lower(value.manually_selected_outpoints)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.send_amount, buf)
        _UniffiConverterUInt32.write(value.maker_count, buf)
        _UniffiConverterOptionalSequenceTypeOutPoint.write(value.manually_selected_outpoints, buf)


class SwapReport:
    swap_id: "str"
    swap_duration_seconds: "float"
    target_amount: "int"
    total_input_amount: "int"
    total_output_amount: "int"
    makers_count: "int"
    maker_addresses: "typing.List[str]"
    total_funding_txs: "int"
    funding_txids_by_hop: "typing.List[typing.List[str]]"
    total_fee: "int"
    total_maker_fees: "int"
    mining_fee: "int"
    fee_percentage: "float"
    maker_fee_info: "typing.List[MakerFeeInfo]"
    input_utxos: "typing.List[int]"
    output_change_amounts: "typing.List[int]"
    output_swap_amounts: "typing.List[int]"
    output_change_utxos: "typing.List[UtxoWithAddress]"
    output_swap_utxos: "typing.List[UtxoWithAddress]"
    def __init__(self, *, swap_id: "str", swap_duration_seconds: "float", target_amount: "int", total_input_amount: "int", total_output_amount: "int", makers_count: "int", maker_addresses: "typing.List[str]", total_funding_txs: "int", funding_txids_by_hop: "typing.List[typing.List[str]]", total_fee: "int", total_maker_fees: "int", mining_fee: "int", fee_percentage: "float", maker_fee_info: "typing.List[MakerFeeInfo]", input_utxos: "typing.List[int]", output_change_amounts: "typing.List[int]", output_swap_amounts: "typing.List[int]", output_change_utxos: "typing.List[UtxoWithAddress]", output_swap_utxos: "typing.List[UtxoWithAddress]"):
        self.swap_id = swap_id
        self.swap_duration_seconds = swap_duration_seconds
        self.target_amount = target_amount
        self.total_input_amount = total_input_amount
        self.total_output_amount = total_output_amount
        self.makers_count = makers_count
        self.maker_addresses = maker_addresses
        self.total_funding_txs = total_funding_txs
        self.funding_txids_by_hop = funding_txids_by_hop
        self.total_fee = total_fee
        self.total_maker_fees = total_maker_fees
        self.mining_fee = mining_fee
        self.fee_percentage = fee_percentage
        self.maker_fee_info = maker_fee_info
        self.input_utxos = input_utxos
        self.output_change_amounts = output_change_amounts
        self.output_swap_amounts = output_swap_amounts
        self.output_change_utxos = output_change_utxos
        self.output_swap_utxos = output_swap_utxos

    def __str__(self):
        return "SwapReport(swap_id={}, swap_duration_seconds={}, target_amount={}, total_input_amount={}, total_output_amount={}, makers_count={}, maker_addresses={}, total_funding_txs={}, funding_txids_by_hop={}, total_fee={}, total_maker_fees={}, mining_fee={}, fee_percentage={}, maker_fee_info={}, input_utxos={}, output_change_amounts={}, output_swap_amounts={}, output_change_utxos={}, output_swap_utxos={})".format(self.swap_id, self.swap_duration_seconds, self.target_amount, self.total_input_amount, self.total_output_amount, self.makers_count, self.maker_addresses, self.total_funding_txs, self.funding_txids_by_hop, self.total_fee, self.total_maker_fees, self.mining_fee, self.fee_percentage, self.maker_fee_info, self.input_utxos, self.output_change_amounts, self.output_swap_amounts, self.output_change_utxos, self.output_swap_utxos)

    def __eq__(self, other):
        if self.swap_id != other.swap_id:
            return False
        if self.swap_duration_seconds != other.swap_duration_seconds:
            return False
        if self.target_amount != other.target_amount:
            return False
        if self.total_input_amount != other.total_input_amount:
            return False
        if self.total_output_amount != other.total_output_amount:
            return False
        if self.makers_count != other.makers_count:
            return False
        if self.maker_addresses != other.maker_addresses:
            return False
        if self.total_funding_txs != other.total_funding_txs:
            return False
        if self.funding_txids_by_hop != other.funding_txids_by_hop:
            return False
        if self.total_fee != other.total_fee:
            return False
        if self.total_maker_fees != other.total_maker_fees:
            return False
        if self.mining_fee != other.mining_fee:
            return False
        if self.fee_percentage != other.fee_percentage:
            return False
        if self.maker_fee_info != other.maker_fee_info:
            return False
        if self.input_utxos != other.input_utxos:
            return False
        if self.output_change_amounts != other.output_change_amounts:
            return False
        if self.output_swap_amounts != other.output_swap_amounts:
            return False
        if self.output_change_utxos != other.output_change_utxos:
            return False
        if self.output_swap_utxos != other.output_swap_utxos:
            return False
        return True

class _UniffiConverterTypeSwapReport(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SwapReport(
            swap_id=_UniffiConverterString.read(buf),
            swap_duration_seconds=_UniffiConverterDouble.read(buf),
            target_amount=_UniffiConverterInt64.read(buf),
            total_input_amount=_UniffiConverterInt64.read(buf),
            total_output_amount=_UniffiConverterInt64.read(buf),
            makers_count=_UniffiConverterUInt32.read(buf),
            maker_addresses=_UniffiConverterSequenceString.read(buf),
            total_funding_txs=_UniffiConverterInt64.read(buf),
            funding_txids_by_hop=_UniffiConverterSequenceSequenceString.read(buf),
            total_fee=_UniffiConverterInt64.read(buf),
            total_maker_fees=_UniffiConverterInt64.read(buf),
            mining_fee=_UniffiConverterInt64.read(buf),
            fee_percentage=_UniffiConverterDouble.read(buf),
            maker_fee_info=_UniffiConverterSequenceTypeMakerFeeInfo.read(buf),
            input_utxos=_UniffiConverterSequenceInt64.read(buf),
            output_change_amounts=_UniffiConverterSequenceInt64.read(buf),
            output_swap_amounts=_UniffiConverterSequenceInt64.read(buf),
            output_change_utxos=_UniffiConverterSequenceTypeUtxoWithAddress.read(buf),
            output_swap_utxos=_UniffiConverterSequenceTypeUtxoWithAddress.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.swap_id)
        _UniffiConverterDouble.check_lower(value.swap_duration_seconds)
        _UniffiConverterInt64.check_lower(value.target_amount)
        _UniffiConverterInt64.check_lower(value.total_input_amount)
        _UniffiConverterInt64.check_lower(value.total_output_amount)
        _UniffiConverterUInt32.check_lower(value.makers_count)
        _UniffiConverterSequenceString.check_lower(value.maker_addresses)
        _UniffiConverterInt64.check_lower(value.total_funding_txs)
        _UniffiConverterSequenceSequenceString.check_lower(value.funding_txids_by_hop)
        _UniffiConverterInt64.check_lower(value.total_fee)
        _UniffiConverterInt64.check_lower(value.total_maker_fees)
        _UniffiConverterInt64.check_lower(value.mining_fee)
        _UniffiConverterDouble.check_lower(value.fee_percentage)
        _UniffiConverterSequenceTypeMakerFeeInfo.check_lower(value.maker_fee_info)
        _UniffiConverterSequenceInt64.check_lower(value.input_utxos)
        _UniffiConverterSequenceInt64.check_lower(value.output_change_amounts)
        _UniffiConverterSequenceInt64.check_lower(value.output_swap_amounts)
        _UniffiConverterSequenceTypeUtxoWithAddress.check_lower(value.output_change_utxos)
        _UniffiConverterSequenceTypeUtxoWithAddress.check_lower(value.output_swap_utxos)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.swap_id, buf)
        _UniffiConverterDouble.write(value.swap_duration_seconds, buf)
        _UniffiConverterInt64.write(value.target_amount, buf)
        _UniffiConverterInt64.write(value.total_input_amount, buf)
        _UniffiConverterInt64.write(value.total_output_amount, buf)
        _UniffiConverterUInt32.write(value.makers_count, buf)
        _UniffiConverterSequenceString.write(value.maker_addresses, buf)
        _UniffiConverterInt64.write(value.total_funding_txs, buf)
        _UniffiConverterSequenceSequenceString.write(value.funding_txids_by_hop, buf)
        _UniffiConverterInt64.write(value.total_fee, buf)
        _UniffiConverterInt64.write(value.total_maker_fees, buf)
        _UniffiConverterInt64.write(value.mining_fee, buf)
        _UniffiConverterDouble.write(value.fee_percentage, buf)
        _UniffiConverterSequenceTypeMakerFeeInfo.write(value.maker_fee_info, buf)
        _UniffiConverterSequenceInt64.write(value.input_utxos, buf)
        _UniffiConverterSequenceInt64.write(value.output_change_amounts, buf)
        _UniffiConverterSequenceInt64.write(value.output_swap_amounts, buf)
        _UniffiConverterSequenceTypeUtxoWithAddress.write(value.output_change_utxos, buf)
        _UniffiConverterSequenceTypeUtxoWithAddress.write(value.output_swap_utxos, buf)


class Txid:
    value: "str"
    def __init__(self, *, value: "str"):
        self.value = value

    def __str__(self):
        return "Txid(value={})".format(self.value)

    def __eq__(self, other):
        if self.value != other.value:
            return False
        return True

class _UniffiConverterTypeTxid(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Txid(
            value=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.value)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.value, buf)


class UtxoSpendInfo:
    spend_type: "str"
    path: "typing.Optional[str]"
    multisig_redeemscript: "typing.Optional[ScriptBuf]"
    input_value: "typing.Optional[Amount]"
    index: "typing.Optional[int]"
    original_multisig_redeemscript: "typing.Optional[ScriptBuf]"
    def __init__(self, *, spend_type: "str", path: "typing.Optional[str]", multisig_redeemscript: "typing.Optional[ScriptBuf]", input_value: "typing.Optional[Amount]", index: "typing.Optional[int]", original_multisig_redeemscript: "typing.Optional[ScriptBuf]"):
        self.spend_type = spend_type
        self.path = path
        self.multisig_redeemscript = multisig_redeemscript
        self.input_value = input_value
        self.index = index
        self.original_multisig_redeemscript = original_multisig_redeemscript

    def __str__(self):
        return "UtxoSpendInfo(spend_type={}, path={}, multisig_redeemscript={}, input_value={}, index={}, original_multisig_redeemscript={})".format(self.spend_type, self.path, self.multisig_redeemscript, self.input_value, self.index, self.original_multisig_redeemscript)

    def __eq__(self, other):
        if self.spend_type != other.spend_type:
            return False
        if self.path != other.path:
            return False
        if self.multisig_redeemscript != other.multisig_redeemscript:
            return False
        if self.input_value != other.input_value:
            return False
        if self.index != other.index:
            return False
        if self.original_multisig_redeemscript != other.original_multisig_redeemscript:
            return False
        return True

class _UniffiConverterTypeUtxoSpendInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return UtxoSpendInfo(
            spend_type=_UniffiConverterString.read(buf),
            path=_UniffiConverterOptionalString.read(buf),
            multisig_redeemscript=_UniffiConverterOptionalTypeScriptBuf.read(buf),
            input_value=_UniffiConverterOptionalTypeAmount.read(buf),
            index=_UniffiConverterOptionalUInt32.read(buf),
            original_multisig_redeemscript=_UniffiConverterOptionalTypeScriptBuf.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.spend_type)
        _UniffiConverterOptionalString.check_lower(value.path)
        _UniffiConverterOptionalTypeScriptBuf.check_lower(value.multisig_redeemscript)
        _UniffiConverterOptionalTypeAmount.check_lower(value.input_value)
        _UniffiConverterOptionalUInt32.check_lower(value.index)
        _UniffiConverterOptionalTypeScriptBuf.check_lower(value.original_multisig_redeemscript)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.spend_type, buf)
        _UniffiConverterOptionalString.write(value.path, buf)
        _UniffiConverterOptionalTypeScriptBuf.write(value.multisig_redeemscript, buf)
        _UniffiConverterOptionalTypeAmount.write(value.input_value, buf)
        _UniffiConverterOptionalUInt32.write(value.index, buf)
        _UniffiConverterOptionalTypeScriptBuf.write(value.original_multisig_redeemscript, buf)


class UtxoWithAddress:
    amount: "int"
    address: "str"
    def __init__(self, *, amount: "int", address: "str"):
        self.amount = amount
        self.address = address

    def __str__(self):
        return "UtxoWithAddress(amount={}, address={})".format(self.amount, self.address)

    def __eq__(self, other):
        if self.amount != other.amount:
            return False
        if self.address != other.address:
            return False
        return True

class _UniffiConverterTypeUtxoWithAddress(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return UtxoWithAddress(
            amount=_UniffiConverterInt64.read(buf),
            address=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterInt64.check_lower(value.amount)
        _UniffiConverterString.check_lower(value.address)

    @staticmethod
    def write(value, buf):
        _UniffiConverterInt64.write(value.amount, buf)
        _UniffiConverterString.write(value.address, buf)


class WalletTxInfo:
    confirmations: "int"
    blockhash: "typing.Optional[str]"
    blockindex: "typing.Optional[int]"
    blocktime: "typing.Optional[int]"
    blockheight: "typing.Optional[int]"
    txid: "Txid"
    time: "int"
    timereceived: "int"
    bip125_replaceable: "str"
    wallet_conflicts: "typing.List[Txid]"
    def __init__(self, *, confirmations: "int", blockhash: "typing.Optional[str]", blockindex: "typing.Optional[int]", blocktime: "typing.Optional[int]", blockheight: "typing.Optional[int]", txid: "Txid", time: "int", timereceived: "int", bip125_replaceable: "str", wallet_conflicts: "typing.List[Txid]"):
        self.confirmations = confirmations
        self.blockhash = blockhash
        self.blockindex = blockindex
        self.blocktime = blocktime
        self.blockheight = blockheight
        self.txid = txid
        self.time = time
        self.timereceived = timereceived
        self.bip125_replaceable = bip125_replaceable
        self.wallet_conflicts = wallet_conflicts

    def __str__(self):
        return "WalletTxInfo(confirmations={}, blockhash={}, blockindex={}, blocktime={}, blockheight={}, txid={}, time={}, timereceived={}, bip125_replaceable={}, wallet_conflicts={})".format(self.confirmations, self.blockhash, self.blockindex, self.blocktime, self.blockheight, self.txid, self.time, self.timereceived, self.bip125_replaceable, self.wallet_conflicts)

    def __eq__(self, other):
        if self.confirmations != other.confirmations:
            return False
        if self.blockhash != other.blockhash:
            return False
        if self.blockindex != other.blockindex:
            return False
        if self.blocktime != other.blocktime:
            return False
        if self.blockheight != other.blockheight:
            return False
        if self.txid != other.txid:
            return False
        if self.time != other.time:
            return False
        if self.timereceived != other.timereceived:
            return False
        if self.bip125_replaceable != other.bip125_replaceable:
            return False
        if self.wallet_conflicts != other.wallet_conflicts:
            return False
        return True

class _UniffiConverterTypeWalletTxInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return WalletTxInfo(
            confirmations=_UniffiConverterInt32.read(buf),
            blockhash=_UniffiConverterOptionalString.read(buf),
            blockindex=_UniffiConverterOptionalUInt32.read(buf),
            blocktime=_UniffiConverterOptionalInt64.read(buf),
            blockheight=_UniffiConverterOptionalUInt32.read(buf),
            txid=_UniffiConverterTypeTxid.read(buf),
            time=_UniffiConverterInt64.read(buf),
            timereceived=_UniffiConverterInt64.read(buf),
            bip125_replaceable=_UniffiConverterString.read(buf),
            wallet_conflicts=_UniffiConverterSequenceTypeTxid.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterInt32.check_lower(value.confirmations)
        _UniffiConverterOptionalString.check_lower(value.blockhash)
        _UniffiConverterOptionalUInt32.check_lower(value.blockindex)
        _UniffiConverterOptionalInt64.check_lower(value.blocktime)
        _UniffiConverterOptionalUInt32.check_lower(value.blockheight)
        _UniffiConverterTypeTxid.check_lower(value.txid)
        _UniffiConverterInt64.check_lower(value.time)
        _UniffiConverterInt64.check_lower(value.timereceived)
        _UniffiConverterString.check_lower(value.bip125_replaceable)
        _UniffiConverterSequenceTypeTxid.check_lower(value.wallet_conflicts)

    @staticmethod
    def write(value, buf):
        _UniffiConverterInt32.write(value.confirmations, buf)
        _UniffiConverterOptionalString.write(value.blockhash, buf)
        _UniffiConverterOptionalUInt32.write(value.blockindex, buf)
        _UniffiConverterOptionalInt64.write(value.blocktime, buf)
        _UniffiConverterOptionalUInt32.write(value.blockheight, buf)
        _UniffiConverterTypeTxid.write(value.txid, buf)
        _UniffiConverterInt64.write(value.time, buf)
        _UniffiConverterInt64.write(value.timereceived, buf)
        _UniffiConverterString.write(value.bip125_replaceable, buf)
        _UniffiConverterSequenceTypeTxid.write(value.wallet_conflicts, buf)


class WalletTxInfo2:
    outpoint: "OutPoint"
    listunspent: "ListUnspentResultEntry"
    spend_info: "UtxoSpendInfo"
    def __init__(self, *, outpoint: "OutPoint", listunspent: "ListUnspentResultEntry", spend_info: "UtxoSpendInfo"):
        self.outpoint = outpoint
        self.listunspent = listunspent
        self.spend_info = spend_info

    def __str__(self):
        return "WalletTxInfo2(outpoint={}, listunspent={}, spend_info={})".format(self.outpoint, self.listunspent, self.spend_info)

    def __eq__(self, other):
        if self.outpoint != other.outpoint:
            return False
        if self.listunspent != other.listunspent:
            return False
        if self.spend_info != other.spend_info:
            return False
        return True

class _UniffiConverterTypeWalletTxInfo2(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return WalletTxInfo2(
            outpoint=_UniffiConverterTypeOutPoint.read(buf),
            listunspent=_UniffiConverterTypeListUnspentResultEntry.read(buf),
            spend_info=_UniffiConverterTypeUtxoSpendInfo.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeOutPoint.check_lower(value.outpoint)
        _UniffiConverterTypeListUnspentResultEntry.check_lower(value.listunspent)
        _UniffiConverterTypeUtxoSpendInfo.check_lower(value.spend_info)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeOutPoint.write(value.outpoint, buf)
        _UniffiConverterTypeListUnspentResultEntry.write(value.listunspent, buf)
        _UniffiConverterTypeUtxoSpendInfo.write(value.spend_info, buf)





class TakerBehavior(enum.Enum):
    NORMAL = 0
    
    DROP_CONNECTION_AFTER_FULL_SETUP = 1
    
    BROADCAST_CONTRACT_AFTER_FULL_SETUP = 2
    


class _UniffiConverterTypeTakerBehavior(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TakerBehavior.NORMAL
        if variant == 2:
            return TakerBehavior.DROP_CONNECTION_AFTER_FULL_SETUP
        if variant == 3:
            return TakerBehavior.BROADCAST_CONTRACT_AFTER_FULL_SETUP
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == TakerBehavior.NORMAL:
            return
        if value == TakerBehavior.DROP_CONNECTION_AFTER_FULL_SETUP:
            return
        if value == TakerBehavior.BROADCAST_CONTRACT_AFTER_FULL_SETUP:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == TakerBehavior.NORMAL:
            buf.write_i32(1)
        if value == TakerBehavior.DROP_CONNECTION_AFTER_FULL_SETUP:
            buf.write_i32(2)
        if value == TakerBehavior.BROADCAST_CONTRACT_AFTER_FULL_SETUP:
            buf.write_i32(3)




# TakerError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class TakerError(Exception):
    pass

_UniffiTempTakerError = TakerError

class TakerError:  # type: ignore
    class Wallet(_UniffiTempTakerError):
        def __init__(self, msg):
            super().__init__(", ".join([
                "msg={!r}".format(msg),
            ]))
            self.msg = msg

        def __repr__(self):
            return "TakerError.Wallet({})".format(str(self))
    _UniffiTempTakerError.Wallet = Wallet # type: ignore
    class Protocol(_UniffiTempTakerError):
        def __init__(self, msg):
            super().__init__(", ".join([
                "msg={!r}".format(msg),
            ]))
            self.msg = msg

        def __repr__(self):
            return "TakerError.Protocol({})".format(str(self))
    _UniffiTempTakerError.Protocol = Protocol # type: ignore
    class Network(_UniffiTempTakerError):
        def __init__(self, msg):
            super().__init__(", ".join([
                "msg={!r}".format(msg),
            ]))
            self.msg = msg

        def __repr__(self):
            return "TakerError.Network({})".format(str(self))
    _UniffiTempTakerError.Network = Network # type: ignore
    class General(_UniffiTempTakerError):
        def __init__(self, msg):
            super().__init__(", ".join([
                "msg={!r}".format(msg),
            ]))
            self.msg = msg

        def __repr__(self):
            return "TakerError.General({})".format(str(self))
    _UniffiTempTakerError.General = General # type: ignore
    class Io(_UniffiTempTakerError):
        def __init__(self, msg):
            super().__init__(", ".join([
                "msg={!r}".format(msg),
            ]))
            self.msg = msg

        def __repr__(self):
            return "TakerError.Io({})".format(str(self))
    _UniffiTempTakerError.Io = Io # type: ignore

TakerError = _UniffiTempTakerError # type: ignore
del _UniffiTempTakerError


class _UniffiConverterTypeTakerError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TakerError.Wallet(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return TakerError.Protocol(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return TakerError.Network(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return TakerError.General(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return TakerError.Io(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, TakerError.Wallet):
            _UniffiConverterString.check_lower(value.msg)
            return
        if isinstance(value, TakerError.Protocol):
            _UniffiConverterString.check_lower(value.msg)
            return
        if isinstance(value, TakerError.Network):
            _UniffiConverterString.check_lower(value.msg)
            return
        if isinstance(value, TakerError.General):
            _UniffiConverterString.check_lower(value.msg)
            return
        if isinstance(value, TakerError.Io):
            _UniffiConverterString.check_lower(value.msg)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, TakerError.Wallet):
            buf.write_i32(1)
            _UniffiConverterString.write(value.msg, buf)
        if isinstance(value, TakerError.Protocol):
            buf.write_i32(2)
            _UniffiConverterString.write(value.msg, buf)
        if isinstance(value, TakerError.Network):
            buf.write_i32(3)
            _UniffiConverterString.write(value.msg, buf)
        if isinstance(value, TakerError.General):
            buf.write_i32(4)
            _UniffiConverterString.write(value.msg, buf)
        if isinstance(value, TakerError.Io):
            buf.write_i32(5)
            _UniffiConverterString.write(value.msg, buf)



class _UniffiConverterOptionalUInt16(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt16.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt16.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt16.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalUInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt32.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterInt64.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalDouble(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterDouble.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterDouble.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterDouble.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalBool(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterBool.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterBool.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterBool.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeAddress(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeAddress.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeAddress.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeAddress.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeAmount(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeAmount.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeAmount.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeAmount.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeRpcConfig(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeRpcConfig.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeRpcConfig.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeRpcConfig.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeScriptBuf(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeScriptBuf.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeScriptBuf.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeScriptBuf.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSignedAmountSats(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeSignedAmountSats.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSignedAmountSats.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSignedAmountSats.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSwapReport(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeSwapReport.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSwapReport.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSwapReport.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeOutPoint(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeOutPoint.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeOutPoint.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeOutPoint.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterSequenceInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterInt64.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterInt64.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterInt64.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterString.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterString.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeAddress(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeAddress.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeAddress.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeAddress.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeListTransactionResult(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeListTransactionResult.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeListTransactionResult.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeListTransactionResult.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeMakerFeeInfo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeMakerFeeInfo.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeMakerFeeInfo.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeMakerFeeInfo.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeOfferAndAddress(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeOfferAndAddress.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeOfferAndAddress.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeOfferAndAddress.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeOutPoint(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeOutPoint.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeOutPoint.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeOutPoint.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeTxid(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeTxid.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTxid.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTxid.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeUtxoWithAddress(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeUtxoWithAddress.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeUtxoWithAddress.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeUtxoWithAddress.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeWalletTxInfo2(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeWalletTxInfo2.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeWalletTxInfo2.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeWalletTxInfo2.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterSequenceString.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterSequenceString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterSequenceString.read(buf) for i in range(count)
        ]

# objects.
class TakerProtocol(typing.Protocol):
    def backup(self, destination_path: "str",password: "typing.Optional[str]"):
        raise NotImplementedError
    def display_offer(self, maker_offer: "Offer"):
        raise NotImplementedError
    def do_coinswap(self, swap_params: "SwapParams"):
        raise NotImplementedError
    def fetch_all_makers(self, ):
        raise NotImplementedError
    def fetch_good_makers(self, ):
        raise NotImplementedError
    def fetch_offers(self, ):
        raise NotImplementedError
    def get_all_good_makers(self, ):
        raise NotImplementedError
    def get_balances(self, ):
        raise NotImplementedError
    def get_next_external_address(self, ):
        raise NotImplementedError
    def get_next_internal_addresses(self, count: "int"):
        raise NotImplementedError
    def get_transactions(self, count: "typing.Optional[int]",skip: "typing.Optional[int]"):
        raise NotImplementedError
    def get_wallet_name(self, ):
        raise NotImplementedError
    def list_all_utxo_spend_info(self, ):
        raise NotImplementedError
    def lock_unspendable_utxos(self, ):
        raise NotImplementedError
    def recover_from_swap(self, ):
        raise NotImplementedError
    def send_to_address(self, address: "str",amount: "int",fee_rate: "typing.Optional[float]",manually_selected_outpoints: "typing.Optional[typing.List[OutPoint]]"):
        raise NotImplementedError
    def sync_and_save(self, ):
        raise NotImplementedError
    def sync_offerbook(self, ):
        raise NotImplementedError
# Taker is a Rust-only trait - it's a wrapper around a Rust implementation.
class Taker():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_coinswap_ffi_fn_free_taker, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_coinswap_ffi_fn_clone_taker, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def init(cls, data_dir: "typing.Optional[str]",wallet_file_name: "typing.Optional[str]",rpc_config: "typing.Optional[RpcConfig]",control_port: "typing.Optional[int]",tor_auth_password: "typing.Optional[str]",zmq_addr: "str",password: "typing.Optional[str]"):
        _UniffiConverterOptionalString.check_lower(data_dir)
        
        _UniffiConverterOptionalString.check_lower(wallet_file_name)
        
        _UniffiConverterOptionalTypeRpcConfig.check_lower(rpc_config)
        
        _UniffiConverterOptionalUInt16.check_lower(control_port)
        
        _UniffiConverterOptionalString.check_lower(tor_auth_password)
        
        _UniffiConverterString.check_lower(zmq_addr)
        
        _UniffiConverterOptionalString.check_lower(password)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeTakerError,_UniffiLib.uniffi_coinswap_ffi_fn_constructor_taker_init,
        _UniffiConverterOptionalString.lower(data_dir),
        _UniffiConverterOptionalString.lower(wallet_file_name),
        _UniffiConverterOptionalTypeRpcConfig.lower(rpc_config),
        _UniffiConverterOptionalUInt16.lower(control_port),
        _UniffiConverterOptionalString.lower(tor_auth_password),
        _UniffiConverterString.lower(zmq_addr),
        _UniffiConverterOptionalString.lower(password))
        return cls._make_instance_(pointer)



    def backup(self, destination_path: "str",password: "typing.Optional[str]") -> None:
        _UniffiConverterString.check_lower(destination_path)
        
        _UniffiConverterOptionalString.check_lower(password)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeTakerError,_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_backup,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(destination_path),
        _UniffiConverterOptionalString.lower(password))






    def display_offer(self, maker_offer: "Offer") -> "str":
        _UniffiConverterTypeOffer.check_lower(maker_offer)
        
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeTakerError,_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_display_offer,self._uniffi_clone_pointer(),
        _UniffiConverterTypeOffer.lower(maker_offer))
        )





    def do_coinswap(self, swap_params: "SwapParams") -> "typing.Optional[SwapReport]":
        _UniffiConverterTypeSwapParams.check_lower(swap_params)
        
        return _UniffiConverterOptionalTypeSwapReport.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeTakerError,_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_do_coinswap,self._uniffi_clone_pointer(),
        _UniffiConverterTypeSwapParams.lower(swap_params))
        )





    def fetch_all_makers(self, ) -> "typing.List[str]":
        return _UniffiConverterSequenceString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeTakerError,_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_fetch_all_makers,self._uniffi_clone_pointer(),)
        )





    def fetch_good_makers(self, ) -> "typing.List[str]":
        return _UniffiConverterSequenceString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeTakerError,_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_fetch_good_makers,self._uniffi_clone_pointer(),)
        )





    def fetch_offers(self, ) -> "OfferBook":
        return _UniffiConverterTypeOfferBook.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeTakerError,_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_fetch_offers,self._uniffi_clone_pointer(),)
        )





    def get_all_good_makers(self, ) -> "typing.List[str]":
        return _UniffiConverterSequenceString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeTakerError,_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_get_all_good_makers,self._uniffi_clone_pointer(),)
        )





    def get_balances(self, ) -> "Balances":
        return _UniffiConverterTypeBalances.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeTakerError,_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_get_balances,self._uniffi_clone_pointer(),)
        )





    def get_next_external_address(self, ) -> "Address":
        return _UniffiConverterTypeAddress.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeTakerError,_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_get_next_external_address,self._uniffi_clone_pointer(),)
        )





    def get_next_internal_addresses(self, count: "int") -> "typing.List[Address]":
        _UniffiConverterUInt32.check_lower(count)
        
        return _UniffiConverterSequenceTypeAddress.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeTakerError,_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_get_next_internal_addresses,self._uniffi_clone_pointer(),
        _UniffiConverterUInt32.lower(count))
        )





    def get_transactions(self, count: "typing.Optional[int]",skip: "typing.Optional[int]") -> "typing.List[ListTransactionResult]":
        _UniffiConverterOptionalUInt32.check_lower(count)
        
        _UniffiConverterOptionalUInt32.check_lower(skip)
        
        return _UniffiConverterSequenceTypeListTransactionResult.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeTakerError,_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_get_transactions,self._uniffi_clone_pointer(),
        _UniffiConverterOptionalUInt32.lower(count),
        _UniffiConverterOptionalUInt32.lower(skip))
        )





    def get_wallet_name(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeTakerError,_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_get_wallet_name,self._uniffi_clone_pointer(),)
        )





    def list_all_utxo_spend_info(self, ) -> "typing.List[WalletTxInfo2]":
        return _UniffiConverterSequenceTypeWalletTxInfo2.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeTakerError,_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_list_all_utxo_spend_info,self._uniffi_clone_pointer(),)
        )





    def lock_unspendable_utxos(self, ) -> None:
        _uniffi_rust_call_with_error(_UniffiConverterTypeTakerError,_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_lock_unspendable_utxos,self._uniffi_clone_pointer(),)






    def recover_from_swap(self, ) -> None:
        _uniffi_rust_call_with_error(_UniffiConverterTypeTakerError,_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_recover_from_swap,self._uniffi_clone_pointer(),)






    def send_to_address(self, address: "str",amount: "int",fee_rate: "typing.Optional[float]",manually_selected_outpoints: "typing.Optional[typing.List[OutPoint]]") -> "str":
        _UniffiConverterString.check_lower(address)
        
        _UniffiConverterInt64.check_lower(amount)
        
        _UniffiConverterOptionalDouble.check_lower(fee_rate)
        
        _UniffiConverterOptionalSequenceTypeOutPoint.check_lower(manually_selected_outpoints)
        
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeTakerError,_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_send_to_address,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(address),
        _UniffiConverterInt64.lower(amount),
        _UniffiConverterOptionalDouble.lower(fee_rate),
        _UniffiConverterOptionalSequenceTypeOutPoint.lower(manually_selected_outpoints))
        )





    def sync_and_save(self, ) -> None:
        _uniffi_rust_call_with_error(_UniffiConverterTypeTakerError,_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_sync_and_save,self._uniffi_clone_pointer(),)






    def sync_offerbook(self, ) -> None:
        _uniffi_rust_call_with_error(_UniffiConverterTypeTakerError,_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_sync_offerbook,self._uniffi_clone_pointer(),)







class _UniffiConverterTypeTaker:

    @staticmethod
    def lift(value: int):
        return Taker._make_instance_(value)

    @staticmethod
    def check_lower(value: Taker):
        if not isinstance(value, Taker):
            raise TypeError("Expected Taker instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: TakerProtocol):
        if not isinstance(value, Taker):
            raise TypeError("Expected Taker instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: TakerProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))

# Async support

def create_default_rpc_config() -> "RpcConfig":
    return _UniffiConverterTypeRpcConfig.lift(_uniffi_rust_call(_UniffiLib.uniffi_coinswap_ffi_fn_func_create_default_rpc_config,))


def fetch_mempool_fees() -> "FeeRates":
    return _UniffiConverterTypeFeeRates.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeTakerError,_UniffiLib.uniffi_coinswap_ffi_fn_func_fetch_mempool_fees,))


def is_wallet_encrypted(wallet_path: "str") -> "bool":
    _UniffiConverterString.check_lower(wallet_path)
    
    return _UniffiConverterBool.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeTakerError,_UniffiLib.uniffi_coinswap_ffi_fn_func_is_wallet_encrypted,
        _UniffiConverterString.lower(wallet_path)))


def restore_wallet_gui_app(data_dir: "typing.Optional[str]",wallet_file_name: "typing.Optional[str]",rpc_config: "RpcConfig",backup_file_path: "str",password: "typing.Optional[str]") -> None:
    _UniffiConverterOptionalString.check_lower(data_dir)
    
    _UniffiConverterOptionalString.check_lower(wallet_file_name)
    
    _UniffiConverterTypeRpcConfig.check_lower(rpc_config)
    
    _UniffiConverterString.check_lower(backup_file_path)
    
    _UniffiConverterOptionalString.check_lower(password)
    
    _uniffi_rust_call(_UniffiLib.uniffi_coinswap_ffi_fn_func_restore_wallet_gui_app,
        _UniffiConverterOptionalString.lower(data_dir),
        _UniffiConverterOptionalString.lower(wallet_file_name),
        _UniffiConverterTypeRpcConfig.lower(rpc_config),
        _UniffiConverterString.lower(backup_file_path),
        _UniffiConverterOptionalString.lower(password))


def setup_logging(data_dir: "typing.Optional[str]") -> None:
    _UniffiConverterOptionalString.check_lower(data_dir)
    
    _uniffi_rust_call_with_error(_UniffiConverterTypeTakerError,_UniffiLib.uniffi_coinswap_ffi_fn_func_setup_logging,
        _UniffiConverterOptionalString.lower(data_dir))


__all__ = [
    "InternalError",
    "TakerBehavior",
    "TakerError",
    "Address",
    "Amount",
    "Balances",
    "FeeRates",
    "FidelityBond",
    "FidelityProof",
    "GetTransactionResultDetail",
    "ListTransactionResult",
    "ListUnspentResultEntry",
    "LockTime",
    "MakerAddress",
    "MakerFeeInfo",
    "Offer",
    "OfferAndAddress",
    "OfferBook",
    "OutPoint",
    "PublicKey",
    "RpcConfig",
    "ScriptBuf",
    "SignedAmountSats",
    "SwapParams",
    "SwapReport",
    "Txid",
    "UtxoSpendInfo",
    "UtxoWithAddress",
    "WalletTxInfo",
    "WalletTxInfo2",
    "create_default_rpc_config",
    "fetch_mempool_fees",
    "is_wallet_encrypted",
    "restore_wallet_gui_app",
    "setup_logging",
    "Taker",
]

