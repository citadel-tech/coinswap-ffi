# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .rb file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Ruby
# helpers directly inline like we're doing here.

require 'ffi'


module Coinswap
  def self.uniffi_in_range(i, type_name, min, max)
  raise TypeError, "no implicit conversion of #{i} into Integer" unless i.respond_to?(:to_int)
  i = i.to_int
  raise RangeError, "#{type_name} requires #{min} <= value < #{max}" unless (min <= i && i < max)
  i
end

def self.uniffi_utf8(v)
  raise TypeError, "no implicit conversion of #{v} into String" unless v.respond_to?(:to_str)
  v = v.to_str.encode(Encoding::UTF_8)
  raise Encoding::InvalidByteSequenceError, "not a valid UTF-8 encoded string" unless v.valid_encoding?
  v
end

def self.uniffi_bytes(v)
  raise TypeError, "no implicit conversion of #{v} into String" unless v.respond_to?(:to_str)
  v.to_str
end

  class RustBuffer < FFI::Struct
  layout :capacity, :uint64,
         :len,      :uint64,
         :data,     :pointer

  def self.alloc(size)
    return Coinswap.rust_call(:ffi_coinswap_ffi_rustbuffer_alloc, size)
  end

  def self.reserve(rbuf, additional)
    return Coinswap.rust_call(:ffi_coinswap_ffi_rustbuffer_reserve, rbuf, additional)
  end

  def free
    Coinswap.rust_call(:ffi_coinswap_ffi_rustbuffer_free, self)
  end

  def capacity
    self[:capacity]
  end

  def len
    self[:len]
  end

  def len=(value)
    self[:len] = value
  end

  def data
    self[:data]
  end

  def to_s
    "RustBuffer(capacity=#{capacity}, len=#{len}, data=#{data.read_bytes len})"
  end

  # The allocated buffer will be automatically freed if an error occurs, ensuring that
  # we don't accidentally leak it.
  def self.allocWithBuilder
    builder = RustBufferBuilder.new

    begin
      yield builder
    rescue => e
      builder.discard
      raise e
    end
  end

  # The RustBuffer will be freed once the context-manager exits, ensuring that we don't
  # leak it even if an error occurs.
  def consumeWithStream
    stream = RustBufferStream.new self

    yield stream

    raise RuntimeError, 'junk data left in buffer after consuming' if stream.remaining != 0
  ensure
    free
  end# The primitive String type.

  def self.allocFromString(value)
    RustBuffer.allocWithBuilder do |builder|
      builder.write value.encode('utf-8')
      return builder.finalize
    end
  end

  def consumeIntoString
    consumeWithStream do |stream|
      return stream.read(stream.remaining).force_encoding(Encoding::UTF_8)
    end
  end

  # The primitive Bytes type.

  def self.allocFromBytes(value)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_Bytes(value)
      return builder.finalize
    end
  end

  def consumeIntoBytes
    consumeWithStream do |stream|
      return stream.readBytes
    end
  end

  # The Record type Address.

  def self.check_lower_TypeAddress(v)
    
  end

  def self.alloc_from_TypeAddress(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeAddress(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeAddress
    consumeWithStream do |stream|
      return stream.readTypeAddress
    end
  end

  # The Record type Amount.

  def self.check_lower_TypeAmount(v)
    
  end

  def self.alloc_from_TypeAmount(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeAmount(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeAmount
    consumeWithStream do |stream|
      return stream.readTypeAmount
    end
  end

  # The Record type Balances.

  def self.check_lower_TypeBalances(v)
    
    
    
    
    
  end

  def self.alloc_from_TypeBalances(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeBalances(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeBalances
    consumeWithStream do |stream|
      return stream.readTypeBalances
    end
  end

  # The Record type FeeRates.

  def self.check_lower_TypeFeeRates(v)
    
    
    
  end

  def self.alloc_from_TypeFeeRates(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeFeeRates(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeFeeRates
    consumeWithStream do |stream|
      return stream.readTypeFeeRates
    end
  end

  # The Record type FidelityBond.

  def self.check_lower_TypeFidelityBond(v)
    RustBuffer.check_lower_TypeAmount(v.amount)
    RustBuffer.check_lower_TypeLockTime(v.lock_time)
    RustBuffer.check_lower_TypePublicKey(v.pubkey)
  end

  def self.alloc_from_TypeFidelityBond(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeFidelityBond(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeFidelityBond
    consumeWithStream do |stream|
      return stream.readTypeFidelityBond
    end
  end

  # The Record type FidelityProof.

  def self.check_lower_TypeFidelityProof(v)
    RustBuffer.check_lower_TypeFidelityBond(v.bond)
    
    
  end

  def self.alloc_from_TypeFidelityProof(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeFidelityProof(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeFidelityProof
    consumeWithStream do |stream|
      return stream.readTypeFidelityProof
    end
  end

  # The Record type GetTransactionResultDetail.

  def self.check_lower_TypeGetTransactionResultDetail(v)
    RustBuffer.check_lower_OptionalTypeAddress(v.address)
    
    RustBuffer.check_lower_TypeSignedAmountSats(v.amount)
    RustBuffer.check_lower_Optionalstring(v.label)
    
    RustBuffer.check_lower_OptionalTypeSignedAmountSats(v.fee)
    RustBuffer.check_lower_Optionalbool(v.abandoned)
  end

  def self.alloc_from_TypeGetTransactionResultDetail(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeGetTransactionResultDetail(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeGetTransactionResultDetail
    consumeWithStream do |stream|
      return stream.readTypeGetTransactionResultDetail
    end
  end

  # The Record type ListTransactionResult.

  def self.check_lower_TypeListTransactionResult(v)
    RustBuffer.check_lower_TypeWalletTxInfo(v.info)
    RustBuffer.check_lower_TypeGetTransactionResultDetail(v.detail)
    RustBuffer.check_lower_Optionalbool(v.trusted)
    RustBuffer.check_lower_Optionalstring(v.comment)
  end

  def self.alloc_from_TypeListTransactionResult(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeListTransactionResult(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeListTransactionResult
    consumeWithStream do |stream|
      return stream.readTypeListTransactionResult
    end
  end

  # The Record type ListUnspentResultEntry.

  def self.check_lower_TypeListUnspentResultEntry(v)
    RustBuffer.check_lower_TypeTxid(v.txid)
    
    RustBuffer.check_lower_Optionalstring(v.address)
    RustBuffer.check_lower_Optionalstring(v.label)
    RustBuffer.check_lower_TypeScriptBuf(v.script_pub_key)
    RustBuffer.check_lower_TypeAmount(v.amount)
    
    RustBuffer.check_lower_OptionalTypeScriptBuf(v.redeem_script)
    RustBuffer.check_lower_OptionalTypeScriptBuf(v.witness_script)
    
    
    RustBuffer.check_lower_Optionalstring(v.desc)
    
  end

  def self.alloc_from_TypeListUnspentResultEntry(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeListUnspentResultEntry(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeListUnspentResultEntry
    consumeWithStream do |stream|
      return stream.readTypeListUnspentResultEntry
    end
  end

  # The Record type LockTime.

  def self.check_lower_TypeLockTime(v)
    
    
  end

  def self.alloc_from_TypeLockTime(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeLockTime(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeLockTime
    consumeWithStream do |stream|
      return stream.readTypeLockTime
    end
  end

  # The Record type MakerAddress.

  def self.check_lower_TypeMakerAddress(v)
    
  end

  def self.alloc_from_TypeMakerAddress(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeMakerAddress(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeMakerAddress
    consumeWithStream do |stream|
      return stream.readTypeMakerAddress
    end
  end

  # The Record type MakerFeeInfo.

  def self.check_lower_TypeMakerFeeInfo(v)
    
    
    
    
    
    
  end

  def self.alloc_from_TypeMakerFeeInfo(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeMakerFeeInfo(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeMakerFeeInfo
    consumeWithStream do |stream|
      return stream.readTypeMakerFeeInfo
    end
  end

  # The Record type Offer.

  def self.check_lower_TypeOffer(v)
    
    
    
    
    
    
    
    RustBuffer.check_lower_TypePublicKey(v.tweakable_point)
    RustBuffer.check_lower_TypeFidelityProof(v.fidelity)
  end

  def self.alloc_from_TypeOffer(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeOffer(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeOffer
    consumeWithStream do |stream|
      return stream.readTypeOffer
    end
  end

  # The Record type OfferAndAddress.

  def self.check_lower_TypeOfferAndAddress(v)
    RustBuffer.check_lower_TypeOffer(v.offer)
    RustBuffer.check_lower_TypeMakerAddress(v.address)
  end

  def self.alloc_from_TypeOfferAndAddress(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeOfferAndAddress(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeOfferAndAddress
    consumeWithStream do |stream|
      return stream.readTypeOfferAndAddress
    end
  end

  # The Record type OfferBook.

  def self.check_lower_TypeOfferBook(v)
    RustBuffer.check_lower_SequenceTypeOfferAndAddress(v.good_makers)
    RustBuffer.check_lower_SequenceTypeOfferAndAddress(v.all_makers)
  end

  def self.alloc_from_TypeOfferBook(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeOfferBook(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeOfferBook
    consumeWithStream do |stream|
      return stream.readTypeOfferBook
    end
  end

  # The Record type OutPoint.

  def self.check_lower_TypeOutPoint(v)
    RustBuffer.check_lower_TypeTxid(v.txid)
    
  end

  def self.alloc_from_TypeOutPoint(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeOutPoint(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeOutPoint
    consumeWithStream do |stream|
      return stream.readTypeOutPoint
    end
  end

  # The Record type PublicKey.

  def self.check_lower_TypePublicKey(v)
    
    
  end

  def self.alloc_from_TypePublicKey(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypePublicKey(v)
      return builder.finalize
    end
  end

  def consumeIntoTypePublicKey
    consumeWithStream do |stream|
      return stream.readTypePublicKey
    end
  end

  # The Record type RPCConfig.

  def self.check_lower_TypeRPCConfig(v)
    
    
    
    
  end

  def self.alloc_from_TypeRPCConfig(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeRPCConfig(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeRPCConfig
    consumeWithStream do |stream|
      return stream.readTypeRPCConfig
    end
  end

  # The Record type ScriptBuf.

  def self.check_lower_TypeScriptBuf(v)
    
  end

  def self.alloc_from_TypeScriptBuf(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeScriptBuf(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeScriptBuf
    consumeWithStream do |stream|
      return stream.readTypeScriptBuf
    end
  end

  # The Record type SignedAmountSats.

  def self.check_lower_TypeSignedAmountSats(v)
    
  end

  def self.alloc_from_TypeSignedAmountSats(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeSignedAmountSats(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeSignedAmountSats
    consumeWithStream do |stream|
      return stream.readTypeSignedAmountSats
    end
  end

  # The Record type SwapParams.

  def self.check_lower_TypeSwapParams(v)
    
    
    RustBuffer.check_lower_OptionalSequenceTypeOutPoint(v.manually_selected_outpoints)
  end

  def self.alloc_from_TypeSwapParams(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeSwapParams(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeSwapParams
    consumeWithStream do |stream|
      return stream.readTypeSwapParams
    end
  end

  # The Record type SwapReport.

  def self.check_lower_TypeSwapReport(v)
    
    
    
    
    
    
    RustBuffer.check_lower_Sequencestring(v.maker_addresses)
    
    RustBuffer.check_lower_SequenceSequencestring(v.funding_txids_by_hop)
    
    
    
    
    RustBuffer.check_lower_SequenceTypeMakerFeeInfo(v.maker_fee_info)
    RustBuffer.check_lower_Sequencei64(v.input_utxos)
    RustBuffer.check_lower_Sequencei64(v.output_change_amounts)
    RustBuffer.check_lower_Sequencei64(v.output_swap_amounts)
    RustBuffer.check_lower_SequenceTypeUtxoWithAddress(v.output_change_utxos)
    RustBuffer.check_lower_SequenceTypeUtxoWithAddress(v.output_swap_utxos)
  end

  def self.alloc_from_TypeSwapReport(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeSwapReport(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeSwapReport
    consumeWithStream do |stream|
      return stream.readTypeSwapReport
    end
  end

  # The Record type TaprootSwapParams.

  def self.check_lower_TypeTaprootSwapParams(v)
    
    
    RustBuffer.check_lower_Optionalu32(v.tx_count)
    RustBuffer.check_lower_Optionalu32(v.required_confirms)
    RustBuffer.check_lower_OptionalSequenceTypeOutPoint(v.manually_selected_outpoints)
  end

  def self.alloc_from_TypeTaprootSwapParams(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeTaprootSwapParams(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeTaprootSwapParams
    consumeWithStream do |stream|
      return stream.readTypeTaprootSwapParams
    end
  end

  # The Record type TotalUtxoInfo.

  def self.check_lower_TypeTotalUtxoInfo(v)
    RustBuffer.check_lower_TypeListUnspentResultEntry(v.list_unspent_result_entry)
    RustBuffer.check_lower_TypeUtxoSpendInfo(v.utxo_spend_info)
  end

  def self.alloc_from_TypeTotalUtxoInfo(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeTotalUtxoInfo(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeTotalUtxoInfo
    consumeWithStream do |stream|
      return stream.readTypeTotalUtxoInfo
    end
  end

  # The Record type Txid.

  def self.check_lower_TypeTxid(v)
    
  end

  def self.alloc_from_TypeTxid(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeTxid(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeTxid
    consumeWithStream do |stream|
      return stream.readTypeTxid
    end
  end

  # The Record type UtxoSpendInfo.

  def self.check_lower_TypeUtxoSpendInfo(v)
    
    RustBuffer.check_lower_Optionalstring(v.path)
    RustBuffer.check_lower_OptionalTypeScriptBuf(v.multisig_redeemscript)
    RustBuffer.check_lower_OptionalTypeAmount(v.input_value)
    RustBuffer.check_lower_Optionalu32(v.index)
    RustBuffer.check_lower_OptionalTypeScriptBuf(v.original_multisig_redeemscript)
  end

  def self.alloc_from_TypeUtxoSpendInfo(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeUtxoSpendInfo(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeUtxoSpendInfo
    consumeWithStream do |stream|
      return stream.readTypeUtxoSpendInfo
    end
  end

  # The Record type UtxoWithAddress.

  def self.check_lower_TypeUtxoWithAddress(v)
    
    
  end

  def self.alloc_from_TypeUtxoWithAddress(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeUtxoWithAddress(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeUtxoWithAddress
    consumeWithStream do |stream|
      return stream.readTypeUtxoWithAddress
    end
  end

  # The Record type WalletTxInfo.

  def self.check_lower_TypeWalletTxInfo(v)
    
    RustBuffer.check_lower_Optionalstring(v.blockhash)
    RustBuffer.check_lower_Optionalu32(v.blockindex)
    RustBuffer.check_lower_Optionali64(v.blocktime)
    RustBuffer.check_lower_Optionalu32(v.blockheight)
    RustBuffer.check_lower_TypeTxid(v.txid)
    
    
    
    RustBuffer.check_lower_SequenceTypeTxid(v.wallet_conflicts)
  end

  def self.alloc_from_TypeWalletTxInfo(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeWalletTxInfo(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeWalletTxInfo
    consumeWithStream do |stream|
      return stream.readTypeWalletTxInfo
    end
  end

  # The Enum type TakerBehavior.

  def self.check_lower_TypeTakerBehavior(v)
  end

  def self.alloc_from_TypeTakerBehavior(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeTakerBehavior(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeTakerBehavior
    consumeWithStream do |stream|
      return stream.readTypeTakerBehavior
    end
  end
  

  

  # The Optional<T> type for u16.

  def self.check_lower_Optionalu16(v)
    if not v.nil?
      
    end
  end

  def self.alloc_from_Optionalu16(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_Optionalu16(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalu16
    consumeWithStream do |stream|
      return stream.readOptionalu16
    end
  end

  # The Optional<T> type for u32.

  def self.check_lower_Optionalu32(v)
    if not v.nil?
      
    end
  end

  def self.alloc_from_Optionalu32(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_Optionalu32(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalu32
    consumeWithStream do |stream|
      return stream.readOptionalu32
    end
  end

  # The Optional<T> type for i64.

  def self.check_lower_Optionali64(v)
    if not v.nil?
      
    end
  end

  def self.alloc_from_Optionali64(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_Optionali64(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionali64
    consumeWithStream do |stream|
      return stream.readOptionali64
    end
  end

  # The Optional<T> type for f64.

  def self.check_lower_Optionalf64(v)
    if not v.nil?
      
    end
  end

  def self.alloc_from_Optionalf64(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_Optionalf64(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalf64
    consumeWithStream do |stream|
      return stream.readOptionalf64
    end
  end

  # The Optional<T> type for bool.

  def self.check_lower_Optionalbool(v)
    if not v.nil?
      
    end
  end

  def self.alloc_from_Optionalbool(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_Optionalbool(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalbool
    consumeWithStream do |stream|
      return stream.readOptionalbool
    end
  end

  # The Optional<T> type for string.

  def self.check_lower_Optionalstring(v)
    if not v.nil?
      
    end
  end

  def self.alloc_from_Optionalstring(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_Optionalstring(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalstring
    consumeWithStream do |stream|
      return stream.readOptionalstring
    end
  end

  # The Optional<T> type for TypeAddress.

  def self.check_lower_OptionalTypeAddress(v)
    if not v.nil?
      RustBuffer.check_lower_TypeAddress(v)
    end
  end

  def self.alloc_from_OptionalTypeAddress(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalTypeAddress(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalTypeAddress
    consumeWithStream do |stream|
      return stream.readOptionalTypeAddress
    end
  end

  # The Optional<T> type for TypeAmount.

  def self.check_lower_OptionalTypeAmount(v)
    if not v.nil?
      RustBuffer.check_lower_TypeAmount(v)
    end
  end

  def self.alloc_from_OptionalTypeAmount(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalTypeAmount(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalTypeAmount
    consumeWithStream do |stream|
      return stream.readOptionalTypeAmount
    end
  end

  # The Optional<T> type for TypeRPCConfig.

  def self.check_lower_OptionalTypeRPCConfig(v)
    if not v.nil?
      RustBuffer.check_lower_TypeRpcConfig(v)
    end
  end

  def self.alloc_from_OptionalTypeRPCConfig(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalTypeRPCConfig(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalTypeRPCConfig
    consumeWithStream do |stream|
      return stream.readOptionalTypeRPCConfig
    end
  end

  # The Optional<T> type for TypeScriptBuf.

  def self.check_lower_OptionalTypeScriptBuf(v)
    if not v.nil?
      RustBuffer.check_lower_TypeScriptBuf(v)
    end
  end

  def self.alloc_from_OptionalTypeScriptBuf(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalTypeScriptBuf(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalTypeScriptBuf
    consumeWithStream do |stream|
      return stream.readOptionalTypeScriptBuf
    end
  end

  # The Optional<T> type for TypeSignedAmountSats.

  def self.check_lower_OptionalTypeSignedAmountSats(v)
    if not v.nil?
      RustBuffer.check_lower_TypeSignedAmountSats(v)
    end
  end

  def self.alloc_from_OptionalTypeSignedAmountSats(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalTypeSignedAmountSats(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalTypeSignedAmountSats
    consumeWithStream do |stream|
      return stream.readOptionalTypeSignedAmountSats
    end
  end

  # The Optional<T> type for TypeSwapReport.

  def self.check_lower_OptionalTypeSwapReport(v)
    if not v.nil?
      RustBuffer.check_lower_TypeSwapReport(v)
    end
  end

  def self.alloc_from_OptionalTypeSwapReport(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalTypeSwapReport(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalTypeSwapReport
    consumeWithStream do |stream|
      return stream.readOptionalTypeSwapReport
    end
  end

  # The Optional<T> type for SequenceTypeOutPoint.

  def self.check_lower_OptionalSequenceTypeOutPoint(v)
    if not v.nil?
      RustBuffer.check_lower_SequenceTypeOutPoint(v)
    end
  end

  def self.alloc_from_OptionalSequenceTypeOutPoint(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalSequenceTypeOutPoint(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalSequenceTypeOutPoint
    consumeWithStream do |stream|
      return stream.readOptionalSequenceTypeOutPoint
    end
  end

  # The Sequence<T> type for i64.

  def self.check_lower_Sequencei64(v)
    v.each do |item|
      
    end
  end

  def self.alloc_from_Sequencei64(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_Sequencei64(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequencei64
    consumeWithStream do |stream|
      return stream.readSequencei64
    end
  end

  # The Sequence<T> type for string.

  def self.check_lower_Sequencestring(v)
    v.each do |item|
      
    end
  end

  def self.alloc_from_Sequencestring(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_Sequencestring(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequencestring
    consumeWithStream do |stream|
      return stream.readSequencestring
    end
  end

  # The Sequence<T> type for TypeAddress.

  def self.check_lower_SequenceTypeAddress(v)
    v.each do |item|
      RustBuffer.check_lower_TypeAddress(item)
    end
  end

  def self.alloc_from_SequenceTypeAddress(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_SequenceTypeAddress(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceTypeAddress
    consumeWithStream do |stream|
      return stream.readSequenceTypeAddress
    end
  end

  # The Sequence<T> type for TypeListTransactionResult.

  def self.check_lower_SequenceTypeListTransactionResult(v)
    v.each do |item|
      RustBuffer.check_lower_TypeListTransactionResult(item)
    end
  end

  def self.alloc_from_SequenceTypeListTransactionResult(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_SequenceTypeListTransactionResult(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceTypeListTransactionResult
    consumeWithStream do |stream|
      return stream.readSequenceTypeListTransactionResult
    end
  end

  # The Sequence<T> type for TypeMakerFeeInfo.

  def self.check_lower_SequenceTypeMakerFeeInfo(v)
    v.each do |item|
      RustBuffer.check_lower_TypeMakerFeeInfo(item)
    end
  end

  def self.alloc_from_SequenceTypeMakerFeeInfo(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_SequenceTypeMakerFeeInfo(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceTypeMakerFeeInfo
    consumeWithStream do |stream|
      return stream.readSequenceTypeMakerFeeInfo
    end
  end

  # The Sequence<T> type for TypeOfferAndAddress.

  def self.check_lower_SequenceTypeOfferAndAddress(v)
    v.each do |item|
      RustBuffer.check_lower_TypeOfferAndAddress(item)
    end
  end

  def self.alloc_from_SequenceTypeOfferAndAddress(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_SequenceTypeOfferAndAddress(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceTypeOfferAndAddress
    consumeWithStream do |stream|
      return stream.readSequenceTypeOfferAndAddress
    end
  end

  # The Sequence<T> type for TypeOutPoint.

  def self.check_lower_SequenceTypeOutPoint(v)
    v.each do |item|
      RustBuffer.check_lower_TypeOutPoint(item)
    end
  end

  def self.alloc_from_SequenceTypeOutPoint(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_SequenceTypeOutPoint(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceTypeOutPoint
    consumeWithStream do |stream|
      return stream.readSequenceTypeOutPoint
    end
  end

  # The Sequence<T> type for TypeTotalUtxoInfo.

  def self.check_lower_SequenceTypeTotalUtxoInfo(v)
    v.each do |item|
      RustBuffer.check_lower_TypeTotalUtxoInfo(item)
    end
  end

  def self.alloc_from_SequenceTypeTotalUtxoInfo(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_SequenceTypeTotalUtxoInfo(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceTypeTotalUtxoInfo
    consumeWithStream do |stream|
      return stream.readSequenceTypeTotalUtxoInfo
    end
  end

  # The Sequence<T> type for TypeTxid.

  def self.check_lower_SequenceTypeTxid(v)
    v.each do |item|
      RustBuffer.check_lower_TypeTxid(item)
    end
  end

  def self.alloc_from_SequenceTypeTxid(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_SequenceTypeTxid(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceTypeTxid
    consumeWithStream do |stream|
      return stream.readSequenceTypeTxid
    end
  end

  # The Sequence<T> type for TypeUtxoWithAddress.

  def self.check_lower_SequenceTypeUtxoWithAddress(v)
    v.each do |item|
      RustBuffer.check_lower_TypeUtxoWithAddress(item)
    end
  end

  def self.alloc_from_SequenceTypeUtxoWithAddress(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_SequenceTypeUtxoWithAddress(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceTypeUtxoWithAddress
    consumeWithStream do |stream|
      return stream.readSequenceTypeUtxoWithAddress
    end
  end

  # The Sequence<T> type for Sequencestring.

  def self.check_lower_SequenceSequencestring(v)
    v.each do |item|
      RustBuffer.check_lower_Sequencestring(item)
    end
  end

  def self.alloc_from_SequenceSequencestring(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_SequenceSequencestring(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceSequencestring
    consumeWithStream do |stream|
      return stream.readSequenceSequencestring
    end
  end

  
end

module UniFFILib
  class ForeignBytes < FFI::Struct
    layout :len,      :int32,
           :data,     :pointer

    def len
      self[:len]
    end

    def data
      self[:data]
    end

    def to_s
      "ForeignBytes(len=#{len}, data=#{data.read_bytes(len)})"
    end
  end
end

private_constant :UniFFILib
  
# Helper for structured reading of values from a RustBuffer.
class RustBufferStream

  def initialize(rbuf)
    @rbuf = rbuf
    @offset = 0
  end

  def remaining
    @rbuf.len - @offset
  end

  def read(size)
    raise InternalError, 'read past end of rust buffer' if @offset + size > @rbuf.len

    data = @rbuf.data.get_bytes @offset, size

    @offset += size

    data
  end

  def readU16
    unpack_from 2, 'S>'
  end

  def readU32
    unpack_from 4, 'L>'
  end

  def readI32
    unpack_from 4, 'l>'
  end

  def readU64
    unpack_from 8, 'Q>'
  end

  def readI64
    unpack_from 8, 'q>'
  end

  def readF64
    unpack_from 8, 'G'
  end

  def readBool
    v = unpack_from 1, 'c'

    return false if v == 0
    return true if v == 1

    raise InternalError, 'Unexpected byte for Boolean type'
  end

  def readString
    size = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative string length' if size.negative?

    read(size).force_encoding(Encoding::UTF_8)
  end

  def readBytes
    size = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative byte string length' if size.negative?

    read(size).force_encoding(Encoding::BINARY)
  end

  # The Object type Taker.

  def readTypeTaker
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return Taker.uniffi_allocate(pointer)
  end

  # The Object type TaprootTaker.

  def readTypeTaprootTaker
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return TaprootTaker.uniffi_allocate(pointer)
  end

  # The Record type Address.

  def readTypeAddress
    Address.new(
      address: readString
    )
  end

  # The Record type Amount.

  def readTypeAmount
    Amount.new(
      sats: readI64
    )
  end

  # The Record type Balances.

  def readTypeBalances
    Balances.new(
      regular: readI64,
      swap: readI64,
      contract: readI64,
      fidelity: readI64,
      spendable: readI64
    )
  end

  # The Record type FeeRates.

  def readTypeFeeRates
    FeeRates.new(
      fastest: readF64,
      standard: readF64,
      economy: readF64
    )
  end

  # The Record type FidelityBond.

  def readTypeFidelityBond
    FidelityBond.new(
      amount: readTypeAmount,
      lock_time: readTypeLockTime,
      pubkey: readTypePublicKey
    )
  end

  # The Record type FidelityProof.

  def readTypeFidelityProof
    FidelityProof.new(
      bond: readTypeFidelityBond,
      cert_hash: readBytes,
      cert_sig: readBytes
    )
  end

  # The Record type GetTransactionResultDetail.

  def readTypeGetTransactionResultDetail
    GetTransactionResultDetail.new(
      address: readOptionalTypeAddress,
      category: readString,
      amount: readTypeSignedAmountSats,
      label: readOptionalstring,
      vout: readU32,
      fee: readOptionalTypeSignedAmountSats,
      abandoned: readOptionalbool
    )
  end

  # The Record type ListTransactionResult.

  def readTypeListTransactionResult
    ListTransactionResult.new(
      info: readTypeWalletTxInfo,
      detail: readTypeGetTransactionResultDetail,
      trusted: readOptionalbool,
      comment: readOptionalstring
    )
  end

  # The Record type ListUnspentResultEntry.

  def readTypeListUnspentResultEntry
    ListUnspentResultEntry.new(
      txid: readTypeTxid,
      vout: readU32,
      address: readOptionalstring,
      label: readOptionalstring,
      script_pub_key: readTypeScriptBuf,
      amount: readTypeAmount,
      confirmations: readU32,
      redeem_script: readOptionalTypeScriptBuf,
      witness_script: readOptionalTypeScriptBuf,
      spendable: readBool,
      solvable: readBool,
      desc: readOptionalstring,
      safe: readBool
    )
  end

  # The Record type LockTime.

  def readTypeLockTime
    LockTime.new(
      lock_type: readString,
      value: readU32
    )
  end

  # The Record type MakerAddress.

  def readTypeMakerAddress
    MakerAddress.new(
      address: readString
    )
  end

  # The Record type MakerFeeInfo.

  def readTypeMakerFeeInfo
    MakerFeeInfo.new(
      maker_index: readU32,
      maker_address: readString,
      base_fee: readF64,
      amount_relative_fee: readF64,
      time_relative_fee: readF64,
      total_fee: readF64
    )
  end

  # The Record type Offer.

  def readTypeOffer
    Offer.new(
      base_fee: readI64,
      amount_relative_fee_pct: readF64,
      time_relative_fee_pct: readF64,
      required_confirms: readU32,
      minimum_locktime: readU16,
      max_size: readI64,
      min_size: readI64,
      tweakable_point: readTypePublicKey,
      fidelity: readTypeFidelityProof
    )
  end

  # The Record type OfferAndAddress.

  def readTypeOfferAndAddress
    OfferAndAddress.new(
      offer: readTypeOffer,
      address: readTypeMakerAddress
    )
  end

  # The Record type OfferBook.

  def readTypeOfferBook
    OfferBook.new(
      good_makers: readSequenceTypeOfferAndAddress,
      all_makers: readSequenceTypeOfferAndAddress
    )
  end

  # The Record type OutPoint.

  def readTypeOutPoint
    OutPoint.new(
      txid: readTypeTxid,
      vout: readU32
    )
  end

  # The Record type PublicKey.

  def readTypePublicKey
    PublicKey.new(
      compressed: readBool,
      inner: readBytes
    )
  end

  # The Record type RPCConfig.

  def readTypeRpcConfig
    RpcConfig.new(
      url: readString,
      username: readString,
      password: readString,
      wallet_name: readString
    )
  end

  # The Record type ScriptBuf.

  def readTypeScriptBuf
    ScriptBuf.new(
      hex: readString
    )
  end

  # The Record type SignedAmountSats.

  def readTypeSignedAmountSats
    SignedAmountSats.new(
      sats: readI64
    )
  end

  # The Record type SwapParams.

  def readTypeSwapParams
    SwapParams.new(
      send_amount: readU64,
      maker_count: readU32,
      manually_selected_outpoints: readOptionalSequenceTypeOutPoint
    )
  end

  # The Record type SwapReport.

  def readTypeSwapReport
    SwapReport.new(
      swap_id: readString,
      swap_duration_seconds: readF64,
      target_amount: readI64,
      total_input_amount: readI64,
      total_output_amount: readI64,
      makers_count: readU32,
      maker_addresses: readSequencestring,
      total_funding_txs: readI64,
      funding_txids_by_hop: readSequenceSequencestring,
      total_fee: readI64,
      total_maker_fees: readI64,
      mining_fee: readI64,
      fee_percentage: readF64,
      maker_fee_info: readSequenceTypeMakerFeeInfo,
      input_utxos: readSequencei64,
      output_change_amounts: readSequencei64,
      output_swap_amounts: readSequencei64,
      output_change_utxos: readSequenceTypeUtxoWithAddress,
      output_swap_utxos: readSequenceTypeUtxoWithAddress
    )
  end

  # The Record type TaprootSwapParams.

  def readTypeTaprootSwapParams
    TaprootSwapParams.new(
      send_amount: readU64,
      maker_count: readU32,
      tx_count: readOptionalu32,
      required_confirms: readOptionalu32,
      manually_selected_outpoints: readOptionalSequenceTypeOutPoint
    )
  end

  # The Record type TotalUtxoInfo.

  def readTypeTotalUtxoInfo
    TotalUtxoInfo.new(
      list_unspent_result_entry: readTypeListUnspentResultEntry,
      utxo_spend_info: readTypeUtxoSpendInfo
    )
  end

  # The Record type Txid.

  def readTypeTxid
    Txid.new(
      value: readString
    )
  end

  # The Record type UtxoSpendInfo.

  def readTypeUtxoSpendInfo
    UtxoSpendInfo.new(
      spend_type: readString,
      path: readOptionalstring,
      multisig_redeemscript: readOptionalTypeScriptBuf,
      input_value: readOptionalTypeAmount,
      index: readOptionalu32,
      original_multisig_redeemscript: readOptionalTypeScriptBuf
    )
  end

  # The Record type UtxoWithAddress.

  def readTypeUtxoWithAddress
    UtxoWithAddress.new(
      amount: readI64,
      address: readString
    )
  end

  # The Record type WalletTxInfo.

  def readTypeWalletTxInfo
    WalletTxInfo.new(
      confirmations: readI32,
      blockhash: readOptionalstring,
      blockindex: readOptionalu32,
      blocktime: readOptionali64,
      blockheight: readOptionalu32,
      txid: readTypeTxid,
      time: readI64,
      timereceived: readI64,
      bip125_replaceable: readString,
      wallet_conflicts: readSequenceTypeTxid
    )
  end

  
  
  # The Enum type TakerBehavior.

  def readTypeTakerBehavior
    variant = unpack_from 4, 'l>'
    
    if variant == 1
      return TakerBehavior::NORMAL
    end
    if variant == 2
      return TakerBehavior::DROP_CONNECTION_AFTER_FULL_SETUP
    end
    if variant == 3
      return TakerBehavior::BROADCAST_CONTRACT_AFTER_FULL_SETUP
    end

    raise InternalError, 'Unexpected variant tag for TypeTakerBehavior'
  end

  

  

  

  # The Error type TakerError

  def readTypeTakerError
    variant = unpack_from 4, 'l>'
    
    if variant == 1
        return TakerError::Wallet.new(
            readString()
        )
    end
    if variant == 2
        return TakerError::Protocol.new(
            readString()
        )
    end
    if variant == 3
        return TakerError::Network.new(
            readString()
        )
    end
    if variant == 4
        return TakerError::General.new(
            readString()
        )
    end
    if variant == 5
        return TakerError::Io.new(
            readString()
        )
    end

    raise InternalError, 'Unexpected variant tag for TypeTakerError'
  end
  

  # The Optional<T> type for u16.

  def readOptionalu16
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readU16
    else
      raise InternalError, 'Unexpected flag byte for Optionalu16'
    end
  end

  # The Optional<T> type for u32.

  def readOptionalu32
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readU32
    else
      raise InternalError, 'Unexpected flag byte for Optionalu32'
    end
  end

  # The Optional<T> type for i64.

  def readOptionali64
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readI64
    else
      raise InternalError, 'Unexpected flag byte for Optionali64'
    end
  end

  # The Optional<T> type for f64.

  def readOptionalf64
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readF64
    else
      raise InternalError, 'Unexpected flag byte for Optionalf64'
    end
  end

  # The Optional<T> type for bool.

  def readOptionalbool
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readBool
    else
      raise InternalError, 'Unexpected flag byte for Optionalbool'
    end
  end

  # The Optional<T> type for string.

  def readOptionalstring
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readString
    else
      raise InternalError, 'Unexpected flag byte for Optionalstring'
    end
  end

  # The Optional<T> type for TypeAddress.

  def readOptionalTypeAddress
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readTypeAddress
    else
      raise InternalError, 'Unexpected flag byte for OptionalTypeAddress'
    end
  end

  # The Optional<T> type for TypeAmount.

  def readOptionalTypeAmount
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readTypeAmount
    else
      raise InternalError, 'Unexpected flag byte for OptionalTypeAmount'
    end
  end

  # The Optional<T> type for TypeRPCConfig.

  def readOptionalTypeRpcConfig
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readTypeRpcConfig
    else
      raise InternalError, 'Unexpected flag byte for OptionalTypeRpcConfig'
    end
  end

  # The Optional<T> type for TypeScriptBuf.

  def readOptionalTypeScriptBuf
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readTypeScriptBuf
    else
      raise InternalError, 'Unexpected flag byte for OptionalTypeScriptBuf'
    end
  end

  # The Optional<T> type for TypeSignedAmountSats.

  def readOptionalTypeSignedAmountSats
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readTypeSignedAmountSats
    else
      raise InternalError, 'Unexpected flag byte for OptionalTypeSignedAmountSats'
    end
  end

  # The Optional<T> type for TypeSwapReport.

  def readOptionalTypeSwapReport
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readTypeSwapReport
    else
      raise InternalError, 'Unexpected flag byte for OptionalTypeSwapReport'
    end
  end

  # The Optional<T> type for SequenceTypeOutPoint.

  def readOptionalSequenceTypeOutPoint
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readSequenceTypeOutPoint
    else
      raise InternalError, 'Unexpected flag byte for OptionalSequenceTypeOutPoint'
    end
  end

  # The Sequence<T> type for i64.

  def readSequencei64
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readI64
    end

    items
  end

  # The Sequence<T> type for string.

  def readSequencestring
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readString
    end

    items
  end

  # The Sequence<T> type for TypeAddress.

  def readSequenceTypeAddress
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readTypeAddress
    end

    items
  end

  # The Sequence<T> type for TypeListTransactionResult.

  def readSequenceTypeListTransactionResult
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readTypeListTransactionResult
    end

    items
  end

  # The Sequence<T> type for TypeMakerFeeInfo.

  def readSequenceTypeMakerFeeInfo
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readTypeMakerFeeInfo
    end

    items
  end

  # The Sequence<T> type for TypeOfferAndAddress.

  def readSequenceTypeOfferAndAddress
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readTypeOfferAndAddress
    end

    items
  end

  # The Sequence<T> type for TypeOutPoint.

  def readSequenceTypeOutPoint
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readTypeOutPoint
    end

    items
  end

  # The Sequence<T> type for TypeTotalUtxoInfo.

  def readSequenceTypeTotalUtxoInfo
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readTypeTotalUtxoInfo
    end

    items
  end

  # The Sequence<T> type for TypeTxid.

  def readSequenceTypeTxid
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readTypeTxid
    end

    items
  end

  # The Sequence<T> type for TypeUtxoWithAddress.

  def readSequenceTypeUtxoWithAddress
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readTypeUtxoWithAddress
    end

    items
  end

  # The Sequence<T> type for Sequencestring.

  def readSequenceSequencestring
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readSequencestring
    end

    items
  end

  

  def unpack_from(size, format)
    raise InternalError, 'read past end of rust buffer' if @offset + size > @rbuf.len

    value = @rbuf.data.get_bytes(@offset, size).unpack format

    @offset += size

    # TODO: verify this
    raise 'more than one element!!!' if value.size > 1

    value[0]
  end
end

private_constant :RustBufferStream
  
# Helper for structured writing of values into a RustBuffer.
class RustBufferBuilder
  def initialize
    @rust_buf = RustBuffer.alloc 16
    @rust_buf.len = 0
  end

  def finalize
    rbuf = @rust_buf

    @rust_buf = nil

    rbuf
  end

  def discard
    return if @rust_buf.nil?

    rbuf = finalize
    rbuf.free
  end

  def write(value)
    reserve(value.bytes.size) do
      @rust_buf.data.put_array_of_char @rust_buf.len, value.bytes
    end
  end

  def write_U16(v)
    v = Coinswap::uniffi_in_range(v, "u16", 0, 2**16)
    pack_into(2, 'S>', v)
  end

  def write_U32(v)
    v = Coinswap::uniffi_in_range(v, "u32", 0, 2**32)
    pack_into(4, 'L>', v)
  end

  def write_I32(v)
    v = Coinswap::uniffi_in_range(v, "i32", -2**31, 2**31)
    pack_into(4, 'l>', v)
  end

  def write_U64(v)
    v = Coinswap::uniffi_in_range(v, "u64", 0, 2**64)
    pack_into(8, 'Q>', v)
  end

  def write_I64(v)
    v = Coinswap::uniffi_in_range(v, "i64", -2**63, 2**63)
    pack_into(8, 'q>', v)
  end

  def write_F64(v)
    pack_into(8, 'G', v)
  end

  def write_Bool(v)
    pack_into(1, 'c', v ? 1 : 0)
  end

  def write_String(v)
    v = Coinswap::uniffi_utf8(v)
    pack_into 4, 'l>', v.bytes.size
    write v
  end

  def write_Bytes(v)
    v = Coinswap::uniffi_bytes(v)
    pack_into 4, 'l>', v.bytes.size
    write v
  end

  # The Object type Taker.

  def write_TypeTaker(obj)
    pointer = Taker.uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type TaprootTaker.

  def write_TypeTaprootTaker(obj)
    pointer = TaprootTaker.uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Record type Address.

  def write_TypeAddress(v)
    self.write_String(v.address)
  end

  # The Record type Amount.

  def write_TypeAmount(v)
    self.write_I64(v.sats)
  end

  # The Record type Balances.

  def write_TypeBalances(v)
    self.write_I64(v.regular)
    self.write_I64(v.swap)
    self.write_I64(v.contract)
    self.write_I64(v.fidelity)
    self.write_I64(v.spendable)
  end

  # The Record type FeeRates.

  def write_TypeFeeRates(v)
    self.write_F64(v.fastest)
    self.write_F64(v.standard)
    self.write_F64(v.economy)
  end

  # The Record type FidelityBond.

  def write_TypeFidelityBond(v)
    self.write_TypeAmount(v.amount)
    self.write_TypeLockTime(v.lock_time)
    self.write_TypePublicKey(v.pubkey)
  end

  # The Record type FidelityProof.

  def write_TypeFidelityProof(v)
    self.write_TypeFidelityBond(v.bond)
    self.write_Bytes(v.cert_hash)
    self.write_Bytes(v.cert_sig)
  end

  # The Record type GetTransactionResultDetail.

  def write_TypeGetTransactionResultDetail(v)
    self.write_OptionalTypeAddress(v.address)
    self.write_String(v.category)
    self.write_TypeSignedAmountSats(v.amount)
    self.write_Optionalstring(v.label)
    self.write_U32(v.vout)
    self.write_OptionalTypeSignedAmountSats(v.fee)
    self.write_Optionalbool(v.abandoned)
  end

  # The Record type ListTransactionResult.

  def write_TypeListTransactionResult(v)
    self.write_TypeWalletTxInfo(v.info)
    self.write_TypeGetTransactionResultDetail(v.detail)
    self.write_Optionalbool(v.trusted)
    self.write_Optionalstring(v.comment)
  end

  # The Record type ListUnspentResultEntry.

  def write_TypeListUnspentResultEntry(v)
    self.write_TypeTxid(v.txid)
    self.write_U32(v.vout)
    self.write_Optionalstring(v.address)
    self.write_Optionalstring(v.label)
    self.write_TypeScriptBuf(v.script_pub_key)
    self.write_TypeAmount(v.amount)
    self.write_U32(v.confirmations)
    self.write_OptionalTypeScriptBuf(v.redeem_script)
    self.write_OptionalTypeScriptBuf(v.witness_script)
    self.write_Bool(v.spendable)
    self.write_Bool(v.solvable)
    self.write_Optionalstring(v.desc)
    self.write_Bool(v.safe)
  end

  # The Record type LockTime.

  def write_TypeLockTime(v)
    self.write_String(v.lock_type)
    self.write_U32(v.value)
  end

  # The Record type MakerAddress.

  def write_TypeMakerAddress(v)
    self.write_String(v.address)
  end

  # The Record type MakerFeeInfo.

  def write_TypeMakerFeeInfo(v)
    self.write_U32(v.maker_index)
    self.write_String(v.maker_address)
    self.write_F64(v.base_fee)
    self.write_F64(v.amount_relative_fee)
    self.write_F64(v.time_relative_fee)
    self.write_F64(v.total_fee)
  end

  # The Record type Offer.

  def write_TypeOffer(v)
    self.write_I64(v.base_fee)
    self.write_F64(v.amount_relative_fee_pct)
    self.write_F64(v.time_relative_fee_pct)
    self.write_U32(v.required_confirms)
    self.write_U16(v.minimum_locktime)
    self.write_I64(v.max_size)
    self.write_I64(v.min_size)
    self.write_TypePublicKey(v.tweakable_point)
    self.write_TypeFidelityProof(v.fidelity)
  end

  # The Record type OfferAndAddress.

  def write_TypeOfferAndAddress(v)
    self.write_TypeOffer(v.offer)
    self.write_TypeMakerAddress(v.address)
  end

  # The Record type OfferBook.

  def write_TypeOfferBook(v)
    self.write_SequenceTypeOfferAndAddress(v.good_makers)
    self.write_SequenceTypeOfferAndAddress(v.all_makers)
  end

  # The Record type OutPoint.

  def write_TypeOutPoint(v)
    self.write_TypeTxid(v.txid)
    self.write_U32(v.vout)
  end

  # The Record type PublicKey.

  def write_TypePublicKey(v)
    self.write_Bool(v.compressed)
    self.write_Bytes(v.inner)
  end

  # The Record type RPCConfig.

  def write_TypeRpcConfig(v)
    self.write_String(v.url)
    self.write_String(v.username)
    self.write_String(v.password)
    self.write_String(v.wallet_name)
  end

  # The Record type ScriptBuf.

  def write_TypeScriptBuf(v)
    self.write_String(v.hex)
  end

  # The Record type SignedAmountSats.

  def write_TypeSignedAmountSats(v)
    self.write_I64(v.sats)
  end

  # The Record type SwapParams.

  def write_TypeSwapParams(v)
    self.write_U64(v.send_amount)
    self.write_U32(v.maker_count)
    self.write_OptionalSequenceTypeOutPoint(v.manually_selected_outpoints)
  end

  # The Record type SwapReport.

  def write_TypeSwapReport(v)
    self.write_String(v.swap_id)
    self.write_F64(v.swap_duration_seconds)
    self.write_I64(v.target_amount)
    self.write_I64(v.total_input_amount)
    self.write_I64(v.total_output_amount)
    self.write_U32(v.makers_count)
    self.write_Sequencestring(v.maker_addresses)
    self.write_I64(v.total_funding_txs)
    self.write_SequenceSequencestring(v.funding_txids_by_hop)
    self.write_I64(v.total_fee)
    self.write_I64(v.total_maker_fees)
    self.write_I64(v.mining_fee)
    self.write_F64(v.fee_percentage)
    self.write_SequenceTypeMakerFeeInfo(v.maker_fee_info)
    self.write_Sequencei64(v.input_utxos)
    self.write_Sequencei64(v.output_change_amounts)
    self.write_Sequencei64(v.output_swap_amounts)
    self.write_SequenceTypeUtxoWithAddress(v.output_change_utxos)
    self.write_SequenceTypeUtxoWithAddress(v.output_swap_utxos)
  end

  # The Record type TaprootSwapParams.

  def write_TypeTaprootSwapParams(v)
    self.write_U64(v.send_amount)
    self.write_U32(v.maker_count)
    self.write_Optionalu32(v.tx_count)
    self.write_Optionalu32(v.required_confirms)
    self.write_OptionalSequenceTypeOutPoint(v.manually_selected_outpoints)
  end

  # The Record type TotalUtxoInfo.

  def write_TypeTotalUtxoInfo(v)
    self.write_TypeListUnspentResultEntry(v.list_unspent_result_entry)
    self.write_TypeUtxoSpendInfo(v.utxo_spend_info)
  end

  # The Record type Txid.

  def write_TypeTxid(v)
    self.write_String(v.value)
  end

  # The Record type UtxoSpendInfo.

  def write_TypeUtxoSpendInfo(v)
    self.write_String(v.spend_type)
    self.write_Optionalstring(v.path)
    self.write_OptionalTypeScriptBuf(v.multisig_redeemscript)
    self.write_OptionalTypeAmount(v.input_value)
    self.write_Optionalu32(v.index)
    self.write_OptionalTypeScriptBuf(v.original_multisig_redeemscript)
  end

  # The Record type UtxoWithAddress.

  def write_TypeUtxoWithAddress(v)
    self.write_I64(v.amount)
    self.write_String(v.address)
  end

  # The Record type WalletTxInfo.

  def write_TypeWalletTxInfo(v)
    self.write_I32(v.confirmations)
    self.write_Optionalstring(v.blockhash)
    self.write_Optionalu32(v.blockindex)
    self.write_Optionali64(v.blocktime)
    self.write_Optionalu32(v.blockheight)
    self.write_TypeTxid(v.txid)
    self.write_I64(v.time)
    self.write_I64(v.timereceived)
    self.write_String(v.bip125_replaceable)
    self.write_SequenceTypeTxid(v.wallet_conflicts)
  end

  # The Enum type TakerBehavior.

  def write_TypeTakerBehavior(v)
    pack_into(4, 'l>', v)
 end
   

  

  # The Optional<T> type for u16.

  def write_Optionalu16(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_U16(v)
    end
  end

  # The Optional<T> type for u32.

  def write_Optionalu32(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_U32(v)
    end
  end

  # The Optional<T> type for i64.

  def write_Optionali64(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_I64(v)
    end
  end

  # The Optional<T> type for f64.

  def write_Optionalf64(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_F64(v)
    end
  end

  # The Optional<T> type for bool.

  def write_Optionalbool(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_Bool(v)
    end
  end

  # The Optional<T> type for string.

  def write_Optionalstring(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_String(v)
    end
  end

  # The Optional<T> type for TypeAddress.

  def write_OptionalTypeAddress(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_TypeAddress(v)
    end
  end

  # The Optional<T> type for TypeAmount.

  def write_OptionalTypeAmount(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_TypeAmount(v)
    end
  end

  # The Optional<T> type for TypeRPCConfig.

  def write_OptionalTypeRpcConfig(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_TypeRpcConfig(v)
    end
  end

  # The Optional<T> type for TypeScriptBuf.

  def write_OptionalTypeScriptBuf(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_TypeScriptBuf(v)
    end
  end

  # The Optional<T> type for TypeSignedAmountSats.

  def write_OptionalTypeSignedAmountSats(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_TypeSignedAmountSats(v)
    end
  end

  # The Optional<T> type for TypeSwapReport.

  def write_OptionalTypeSwapReport(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_TypeSwapReport(v)
    end
  end

  # The Optional<T> type for SequenceTypeOutPoint.

  def write_OptionalSequenceTypeOutPoint(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_SequenceTypeOutPoint(v)
    end
  end

  # The Sequence<T> type for i64.

  def write_Sequencei64(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_I64(item)
    end
  end

  # The Sequence<T> type for string.

  def write_Sequencestring(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_String(item)
    end
  end

  # The Sequence<T> type for TypeAddress.

  def write_SequenceTypeAddress(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_TypeAddress(item)
    end
  end

  # The Sequence<T> type for TypeListTransactionResult.

  def write_SequenceTypeListTransactionResult(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_TypeListTransactionResult(item)
    end
  end

  # The Sequence<T> type for TypeMakerFeeInfo.

  def write_SequenceTypeMakerFeeInfo(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_TypeMakerFeeInfo(item)
    end
  end

  # The Sequence<T> type for TypeOfferAndAddress.

  def write_SequenceTypeOfferAndAddress(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_TypeOfferAndAddress(item)
    end
  end

  # The Sequence<T> type for TypeOutPoint.

  def write_SequenceTypeOutPoint(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_TypeOutPoint(item)
    end
  end

  # The Sequence<T> type for TypeTotalUtxoInfo.

  def write_SequenceTypeTotalUtxoInfo(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_TypeTotalUtxoInfo(item)
    end
  end

  # The Sequence<T> type for TypeTxid.

  def write_SequenceTypeTxid(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_TypeTxid(item)
    end
  end

  # The Sequence<T> type for TypeUtxoWithAddress.

  def write_SequenceTypeUtxoWithAddress(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_TypeUtxoWithAddress(item)
    end
  end

  # The Sequence<T> type for Sequencestring.

  def write_SequenceSequencestring(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_Sequencestring(item)
    end
  end

  

  private

  def reserve(num_bytes)
    if @rust_buf.len + num_bytes > @rust_buf.capacity
      @rust_buf = RustBuffer.reserve(@rust_buf, num_bytes)
    end

    yield

    @rust_buf.len += num_bytes
  end

  def pack_into(size, format, value)
    reserve(size) do
      @rust_buf.data.put_array_of_char @rust_buf.len, [value].pack(format).bytes
    end
  end
end

private_constant :RustBufferBuilder

  # Error definitions
  class RustCallStatus < FFI::Struct
  layout :code,    :int8,
         :error_buf, RustBuffer

  def code
    self[:code]
  end

  def error_buf
    self[:error_buf]
  end

  def to_s
    "RustCallStatus(code=#{self[:code]})"
  end
end

# These match the values from the uniffi::rustcalls module
CALL_SUCCESS = 0
CALL_ERROR = 1
CALL_PANIC = 2



module TakerError
  class Wallet < StandardError
    def initialize(msg)
        @msg = msg
        super()
      end

    attr_reader :msg
    

    def to_s
     "#{self.class.name}(msg=#{@msg.inspect})"
    end
  end
  class Protocol < StandardError
    def initialize(msg)
        @msg = msg
        super()
      end

    attr_reader :msg
    

    def to_s
     "#{self.class.name}(msg=#{@msg.inspect})"
    end
  end
  class Network < StandardError
    def initialize(msg)
        @msg = msg
        super()
      end

    attr_reader :msg
    

    def to_s
     "#{self.class.name}(msg=#{@msg.inspect})"
    end
  end
  class General < StandardError
    def initialize(msg)
        @msg = msg
        super()
      end

    attr_reader :msg
    

    def to_s
     "#{self.class.name}(msg=#{@msg.inspect})"
    end
  end
  class Io < StandardError
    def initialize(msg)
        @msg = msg
        super()
      end

    attr_reader :msg
    

    def to_s
     "#{self.class.name}(msg=#{@msg.inspect})"
    end
  end

end


# Map error modules to the RustBuffer method name that reads them
ERROR_MODULE_TO_READER_METHOD = {


  TakerError => :readTypeTakerError,

}

private_constant :ERROR_MODULE_TO_READER_METHOD, :CALL_SUCCESS, :CALL_ERROR, :CALL_PANIC,
                 :RustCallStatus

def self.consume_buffer_into_error(error_module, rust_buffer)
  rust_buffer.consumeWithStream do |stream|
    reader_method = ERROR_MODULE_TO_READER_METHOD[error_module]
    return stream.send(reader_method)
  end
end

class InternalError < StandardError
end

def self.rust_call(fn_name, *args)
  # Call a rust function
  rust_call_with_error(nil, fn_name, *args)
end

def self.rust_call_with_error(error_module, fn_name, *args)
  # Call a rust function and handle errors
  #
  # Use this when the rust function returns a Result<>.  error_module must be the error_module that corresponds to that Result.


  # Note: RustCallStatus.new zeroes out the struct, which is exactly what we
  # want to pass to Rust (code=0, error_buf=RustBuffer(len=0, capacity=0,
  # data=NULL))
  status = RustCallStatus.new
  args << status

  result = UniFFILib.public_send(fn_name, *args)

  case status.code
  when CALL_SUCCESS
    result
  when CALL_ERROR
    if error_module.nil?
      status.error_buf.free
      raise InternalError, "CALL_ERROR with no error_module set"
    else
      raise consume_buffer_into_error(error_module, status.error_buf)
    end
  when CALL_PANIC
    # When the rust code sees a panic, it tries to construct a RustBuffer
    # with the message.  But if that code panics, then it just sends back
    # an empty buffer.
    if status.error_buf.len > 0
      raise InternalError, status.error_buf.consumeIntoString()
    else
      raise InternalError, "Rust panic"
    end
  else
    raise InternalError, "Unknown call status: #{status.code}"
  end
end

private_class_method :consume_buffer_into_error

  # This is how we find and load the dynamic library provided by the component.
# For now we just look it up by name.
module UniFFILib
  extend FFI::Library

  
  ffi_lib 'coinswap_ffi'
  

  attach_function :uniffi_coinswap_ffi_fn_clone_taker,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_coinswap_ffi_fn_free_taker,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_coinswap_ffi_fn_constructor_taker_init,
    [RustBuffer.by_value, RustBuffer.by_value, RustBuffer.by_value, RustBuffer.by_value, RustBuffer.by_value, RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_coinswap_ffi_fn_method_taker_backup,
    [:pointer, RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_coinswap_ffi_fn_method_taker_display_offer,
    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_coinswap_ffi_fn_method_taker_do_coinswap,
    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_coinswap_ffi_fn_method_taker_fetch_all_makers,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_coinswap_ffi_fn_method_taker_fetch_good_makers,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_coinswap_ffi_fn_method_taker_fetch_offers,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_coinswap_ffi_fn_method_taker_get_all_good_makers,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_coinswap_ffi_fn_method_taker_get_balances,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_coinswap_ffi_fn_method_taker_get_next_external_address,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_coinswap_ffi_fn_method_taker_get_next_internal_addresses,
    [:pointer, :uint32, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_coinswap_ffi_fn_method_taker_get_transactions,
    [:pointer, RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_coinswap_ffi_fn_method_taker_get_wallet_name,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_coinswap_ffi_fn_method_taker_list_all_utxo_spend_info,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_coinswap_ffi_fn_method_taker_lock_unspendable_utxos,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_coinswap_ffi_fn_method_taker_recover_from_swap,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_coinswap_ffi_fn_method_taker_send_to_address,
    [:pointer, RustBuffer.by_value, :int64, RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_coinswap_ffi_fn_method_taker_sync_and_save,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_coinswap_ffi_fn_method_taker_sync_offerbook,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_coinswap_ffi_fn_clone_taproottaker,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_coinswap_ffi_fn_free_taproottaker,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_coinswap_ffi_fn_constructor_taproottaker_init,
    [RustBuffer.by_value, RustBuffer.by_value, RustBuffer.by_value, RustBuffer.by_value, RustBuffer.by_value, RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_coinswap_ffi_fn_method_taproottaker_backup,
    [:pointer, RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_coinswap_ffi_fn_method_taproottaker_display_offer,
    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_coinswap_ffi_fn_method_taproottaker_do_coinswap,
    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_coinswap_ffi_fn_method_taproottaker_fetch_all_makers,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_coinswap_ffi_fn_method_taproottaker_fetch_good_makers,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_coinswap_ffi_fn_method_taproottaker_fetch_offers,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_coinswap_ffi_fn_method_taproottaker_get_all_good_makers,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_coinswap_ffi_fn_method_taproottaker_get_balances,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_coinswap_ffi_fn_method_taproottaker_get_next_external_address,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_coinswap_ffi_fn_method_taproottaker_get_next_internal_addresses,
    [:pointer, :uint32, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_coinswap_ffi_fn_method_taproottaker_get_transactions,
    [:pointer, RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_coinswap_ffi_fn_method_taproottaker_get_wallet_name,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_coinswap_ffi_fn_method_taproottaker_list_all_utxo_spend_info,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_coinswap_ffi_fn_method_taproottaker_lock_unspendable_utxos,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_coinswap_ffi_fn_method_taproottaker_recover_from_swap,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_coinswap_ffi_fn_method_taproottaker_send_to_address,
    [:pointer, RustBuffer.by_value, :int64, RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_coinswap_ffi_fn_method_taproottaker_sync_and_save,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_coinswap_ffi_fn_method_taproottaker_sync_offerbook,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_coinswap_ffi_fn_func_create_default_rpc_config,
    [RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_coinswap_ffi_fn_func_fetch_mempool_fees,
    [RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_coinswap_ffi_fn_func_is_wallet_encrypted,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :int8
  attach_function :uniffi_coinswap_ffi_fn_func_restore_wallet_gui_app,
    [RustBuffer.by_value, RustBuffer.by_value, RustBuffer.by_value, RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_coinswap_ffi_fn_func_setup_logging,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :void
  attach_function :ffi_coinswap_ffi_rustbuffer_alloc,
    [:uint64, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_coinswap_ffi_rustbuffer_from_bytes,
    [ForeignBytes, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_coinswap_ffi_rustbuffer_free,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :void
  attach_function :ffi_coinswap_ffi_rustbuffer_reserve,
    [RustBuffer.by_value, :uint64, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_coinswap_ffi_checksum_func_create_default_rpc_config,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_func_fetch_mempool_fees,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_func_is_wallet_encrypted,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_func_restore_wallet_gui_app,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_func_setup_logging,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taker_backup,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taker_display_offer,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taker_do_coinswap,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taker_fetch_all_makers,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taker_fetch_good_makers,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taker_fetch_offers,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taker_get_all_good_makers,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taker_get_balances,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taker_get_next_external_address,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taker_get_next_internal_addresses,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taker_get_transactions,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taker_get_wallet_name,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taker_list_all_utxo_spend_info,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taker_lock_unspendable_utxos,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taker_recover_from_swap,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taker_send_to_address,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taker_sync_and_save,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taker_sync_offerbook,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taproottaker_backup,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taproottaker_display_offer,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taproottaker_do_coinswap,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taproottaker_fetch_all_makers,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taproottaker_fetch_good_makers,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taproottaker_fetch_offers,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taproottaker_get_all_good_makers,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taproottaker_get_balances,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taproottaker_get_next_external_address,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taproottaker_get_next_internal_addresses,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taproottaker_get_transactions,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taproottaker_get_wallet_name,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taproottaker_list_all_utxo_spend_info,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taproottaker_lock_unspendable_utxos,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taproottaker_recover_from_swap,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taproottaker_send_to_address,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taproottaker_sync_and_save,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_method_taproottaker_sync_offerbook,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_constructor_taker_init,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_coinswap_ffi_checksum_constructor_taproottaker_init,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :ffi_coinswap_ffi_uniffi_contract_version,
    [RustCallStatus.by_ref],
    :uint32
  
end

  # Public interface members begin here.

  
  
  

class TakerBehavior
  NORMAL = 1
  DROP_CONNECTION_AFTER_FULL_SETUP = 2
  BROADCAST_CONTRACT_AFTER_FULL_SETUP = 3
  
end


  
  
  # Record type Address
class Address
  attr_reader :address

  def initialize(address:)
    @address = address
  end

  def ==(other)
    if @address != other.address
      return false
    end

    true
  end
end
  
  # Record type Amount
class Amount
  attr_reader :sats

  def initialize(sats:)
    @sats = sats
  end

  def ==(other)
    if @sats != other.sats
      return false
    end

    true
  end
end
  
  # Record type Balances
class Balances
  attr_reader :regular, :swap, :contract, :fidelity, :spendable

  def initialize(regular:, swap:, contract:, fidelity:, spendable:)
    @regular = regular
    @swap = swap
    @contract = contract
    @fidelity = fidelity
    @spendable = spendable
  end

  def ==(other)
    if @regular != other.regular
      return false
    end
    if @swap != other.swap
      return false
    end
    if @contract != other.contract
      return false
    end
    if @fidelity != other.fidelity
      return false
    end
    if @spendable != other.spendable
      return false
    end

    true
  end
end
  
  # Record type FeeRates
class FeeRates
  attr_reader :fastest, :standard, :economy

  def initialize(fastest:, standard:, economy:)
    @fastest = fastest
    @standard = standard
    @economy = economy
  end

  def ==(other)
    if @fastest != other.fastest
      return false
    end
    if @standard != other.standard
      return false
    end
    if @economy != other.economy
      return false
    end

    true
  end
end
  
  # Record type FidelityBond
class FidelityBond
  attr_reader :amount, :lock_time, :pubkey

  def initialize(amount:, lock_time:, pubkey:)
    @amount = amount
    @lock_time = lock_time
    @pubkey = pubkey
  end

  def ==(other)
    if @amount != other.amount
      return false
    end
    if @lock_time != other.lock_time
      return false
    end
    if @pubkey != other.pubkey
      return false
    end

    true
  end
end
  
  # Record type FidelityProof
class FidelityProof
  attr_reader :bond, :cert_hash, :cert_sig

  def initialize(bond:, cert_hash:, cert_sig:)
    @bond = bond
    @cert_hash = cert_hash
    @cert_sig = cert_sig
  end

  def ==(other)
    if @bond != other.bond
      return false
    end
    if @cert_hash != other.cert_hash
      return false
    end
    if @cert_sig != other.cert_sig
      return false
    end

    true
  end
end
  
  # Record type GetTransactionResultDetail
class GetTransactionResultDetail
  attr_reader :address, :category, :amount, :label, :vout, :fee, :abandoned

  def initialize(address:, category:, amount:, label:, vout:, fee:, abandoned:)
    @address = address
    @category = category
    @amount = amount
    @label = label
    @vout = vout
    @fee = fee
    @abandoned = abandoned
  end

  def ==(other)
    if @address != other.address
      return false
    end
    if @category != other.category
      return false
    end
    if @amount != other.amount
      return false
    end
    if @label != other.label
      return false
    end
    if @vout != other.vout
      return false
    end
    if @fee != other.fee
      return false
    end
    if @abandoned != other.abandoned
      return false
    end

    true
  end
end
  
  # Record type ListTransactionResult
class ListTransactionResult
  attr_reader :info, :detail, :trusted, :comment

  def initialize(info:, detail:, trusted:, comment:)
    @info = info
    @detail = detail
    @trusted = trusted
    @comment = comment
  end

  def ==(other)
    if @info != other.info
      return false
    end
    if @detail != other.detail
      return false
    end
    if @trusted != other.trusted
      return false
    end
    if @comment != other.comment
      return false
    end

    true
  end
end
  
  # Record type ListUnspentResultEntry
class ListUnspentResultEntry
  attr_reader :txid, :vout, :address, :label, :script_pub_key, :amount, :confirmations, :redeem_script, :witness_script, :spendable, :solvable, :desc, :safe

  def initialize(txid:, vout:, address:, label:, script_pub_key:, amount:, confirmations:, redeem_script:, witness_script:, spendable:, solvable:, desc:, safe:)
    @txid = txid
    @vout = vout
    @address = address
    @label = label
    @script_pub_key = script_pub_key
    @amount = amount
    @confirmations = confirmations
    @redeem_script = redeem_script
    @witness_script = witness_script
    @spendable = spendable
    @solvable = solvable
    @desc = desc
    @safe = safe
  end

  def ==(other)
    if @txid != other.txid
      return false
    end
    if @vout != other.vout
      return false
    end
    if @address != other.address
      return false
    end
    if @label != other.label
      return false
    end
    if @script_pub_key != other.script_pub_key
      return false
    end
    if @amount != other.amount
      return false
    end
    if @confirmations != other.confirmations
      return false
    end
    if @redeem_script != other.redeem_script
      return false
    end
    if @witness_script != other.witness_script
      return false
    end
    if @spendable != other.spendable
      return false
    end
    if @solvable != other.solvable
      return false
    end
    if @desc != other.desc
      return false
    end
    if @safe != other.safe
      return false
    end

    true
  end
end
  
  # Record type LockTime
class LockTime
  attr_reader :lock_type, :value

  def initialize(lock_type:, value:)
    @lock_type = lock_type
    @value = value
  end

  def ==(other)
    if @lock_type != other.lock_type
      return false
    end
    if @value != other.value
      return false
    end

    true
  end
end
  
  # Record type MakerAddress
class MakerAddress
  attr_reader :address

  def initialize(address:)
    @address = address
  end

  def ==(other)
    if @address != other.address
      return false
    end

    true
  end
end
  
  # Record type MakerFeeInfo
class MakerFeeInfo
  attr_reader :maker_index, :maker_address, :base_fee, :amount_relative_fee, :time_relative_fee, :total_fee

  def initialize(maker_index:, maker_address:, base_fee:, amount_relative_fee:, time_relative_fee:, total_fee:)
    @maker_index = maker_index
    @maker_address = maker_address
    @base_fee = base_fee
    @amount_relative_fee = amount_relative_fee
    @time_relative_fee = time_relative_fee
    @total_fee = total_fee
  end

  def ==(other)
    if @maker_index != other.maker_index
      return false
    end
    if @maker_address != other.maker_address
      return false
    end
    if @base_fee != other.base_fee
      return false
    end
    if @amount_relative_fee != other.amount_relative_fee
      return false
    end
    if @time_relative_fee != other.time_relative_fee
      return false
    end
    if @total_fee != other.total_fee
      return false
    end

    true
  end
end
  
  # Record type Offer
class Offer
  attr_reader :base_fee, :amount_relative_fee_pct, :time_relative_fee_pct, :required_confirms, :minimum_locktime, :max_size, :min_size, :tweakable_point, :fidelity

  def initialize(base_fee:, amount_relative_fee_pct:, time_relative_fee_pct:, required_confirms:, minimum_locktime:, max_size:, min_size:, tweakable_point:, fidelity:)
    @base_fee = base_fee
    @amount_relative_fee_pct = amount_relative_fee_pct
    @time_relative_fee_pct = time_relative_fee_pct
    @required_confirms = required_confirms
    @minimum_locktime = minimum_locktime
    @max_size = max_size
    @min_size = min_size
    @tweakable_point = tweakable_point
    @fidelity = fidelity
  end

  def ==(other)
    if @base_fee != other.base_fee
      return false
    end
    if @amount_relative_fee_pct != other.amount_relative_fee_pct
      return false
    end
    if @time_relative_fee_pct != other.time_relative_fee_pct
      return false
    end
    if @required_confirms != other.required_confirms
      return false
    end
    if @minimum_locktime != other.minimum_locktime
      return false
    end
    if @max_size != other.max_size
      return false
    end
    if @min_size != other.min_size
      return false
    end
    if @tweakable_point != other.tweakable_point
      return false
    end
    if @fidelity != other.fidelity
      return false
    end

    true
  end
end
  
  # Record type OfferAndAddress
class OfferAndAddress
  attr_reader :offer, :address

  def initialize(offer:, address:)
    @offer = offer
    @address = address
  end

  def ==(other)
    if @offer != other.offer
      return false
    end
    if @address != other.address
      return false
    end

    true
  end
end
  
  # Record type OfferBook
class OfferBook
  attr_reader :good_makers, :all_makers

  def initialize(good_makers:, all_makers:)
    @good_makers = good_makers
    @all_makers = all_makers
  end

  def ==(other)
    if @good_makers != other.good_makers
      return false
    end
    if @all_makers != other.all_makers
      return false
    end

    true
  end
end
  
  # Record type OutPoint
class OutPoint
  attr_reader :txid, :vout

  def initialize(txid:, vout:)
    @txid = txid
    @vout = vout
  end

  def ==(other)
    if @txid != other.txid
      return false
    end
    if @vout != other.vout
      return false
    end

    true
  end
end
  
  # Record type PublicKey
class PublicKey
  attr_reader :compressed, :inner

  def initialize(compressed:, inner:)
    @compressed = compressed
    @inner = inner
  end

  def ==(other)
    if @compressed != other.compressed
      return false
    end
    if @inner != other.inner
      return false
    end

    true
  end
end
  
  # Record type RPCConfig
class RpcConfig
  attr_reader :url, :username, :password, :wallet_name

  def initialize(url:, username:, password:, wallet_name:)
    @url = url
    @username = username
    @password = password
    @wallet_name = wallet_name
  end

  def ==(other)
    if @url != other.url
      return false
    end
    if @username != other.username
      return false
    end
    if @password != other.password
      return false
    end
    if @wallet_name != other.wallet_name
      return false
    end

    true
  end
end
  
  # Record type ScriptBuf
class ScriptBuf
  attr_reader :hex

  def initialize(hex:)
    @hex = hex
  end

  def ==(other)
    if @hex != other.hex
      return false
    end

    true
  end
end
  
  # Record type SignedAmountSats
class SignedAmountSats
  attr_reader :sats

  def initialize(sats:)
    @sats = sats
  end

  def ==(other)
    if @sats != other.sats
      return false
    end

    true
  end
end
  
  # Record type SwapParams
class SwapParams
  attr_reader :send_amount, :maker_count, :manually_selected_outpoints

  def initialize(send_amount:, maker_count:, manually_selected_outpoints:)
    @send_amount = send_amount
    @maker_count = maker_count
    @manually_selected_outpoints = manually_selected_outpoints
  end

  def ==(other)
    if @send_amount != other.send_amount
      return false
    end
    if @maker_count != other.maker_count
      return false
    end
    if @manually_selected_outpoints != other.manually_selected_outpoints
      return false
    end

    true
  end
end
  
  # Record type SwapReport
class SwapReport
  attr_reader :swap_id, :swap_duration_seconds, :target_amount, :total_input_amount, :total_output_amount, :makers_count, :maker_addresses, :total_funding_txs, :funding_txids_by_hop, :total_fee, :total_maker_fees, :mining_fee, :fee_percentage, :maker_fee_info, :input_utxos, :output_change_amounts, :output_swap_amounts, :output_change_utxos, :output_swap_utxos

  def initialize(swap_id:, swap_duration_seconds:, target_amount:, total_input_amount:, total_output_amount:, makers_count:, maker_addresses:, total_funding_txs:, funding_txids_by_hop:, total_fee:, total_maker_fees:, mining_fee:, fee_percentage:, maker_fee_info:, input_utxos:, output_change_amounts:, output_swap_amounts:, output_change_utxos:, output_swap_utxos:)
    @swap_id = swap_id
    @swap_duration_seconds = swap_duration_seconds
    @target_amount = target_amount
    @total_input_amount = total_input_amount
    @total_output_amount = total_output_amount
    @makers_count = makers_count
    @maker_addresses = maker_addresses
    @total_funding_txs = total_funding_txs
    @funding_txids_by_hop = funding_txids_by_hop
    @total_fee = total_fee
    @total_maker_fees = total_maker_fees
    @mining_fee = mining_fee
    @fee_percentage = fee_percentage
    @maker_fee_info = maker_fee_info
    @input_utxos = input_utxos
    @output_change_amounts = output_change_amounts
    @output_swap_amounts = output_swap_amounts
    @output_change_utxos = output_change_utxos
    @output_swap_utxos = output_swap_utxos
  end

  def ==(other)
    if @swap_id != other.swap_id
      return false
    end
    if @swap_duration_seconds != other.swap_duration_seconds
      return false
    end
    if @target_amount != other.target_amount
      return false
    end
    if @total_input_amount != other.total_input_amount
      return false
    end
    if @total_output_amount != other.total_output_amount
      return false
    end
    if @makers_count != other.makers_count
      return false
    end
    if @maker_addresses != other.maker_addresses
      return false
    end
    if @total_funding_txs != other.total_funding_txs
      return false
    end
    if @funding_txids_by_hop != other.funding_txids_by_hop
      return false
    end
    if @total_fee != other.total_fee
      return false
    end
    if @total_maker_fees != other.total_maker_fees
      return false
    end
    if @mining_fee != other.mining_fee
      return false
    end
    if @fee_percentage != other.fee_percentage
      return false
    end
    if @maker_fee_info != other.maker_fee_info
      return false
    end
    if @input_utxos != other.input_utxos
      return false
    end
    if @output_change_amounts != other.output_change_amounts
      return false
    end
    if @output_swap_amounts != other.output_swap_amounts
      return false
    end
    if @output_change_utxos != other.output_change_utxos
      return false
    end
    if @output_swap_utxos != other.output_swap_utxos
      return false
    end

    true
  end
end
  
  # Record type TaprootSwapParams
class TaprootSwapParams
  attr_reader :send_amount, :maker_count, :tx_count, :required_confirms, :manually_selected_outpoints

  def initialize(send_amount:, maker_count:, tx_count:, required_confirms:, manually_selected_outpoints:)
    @send_amount = send_amount
    @maker_count = maker_count
    @tx_count = tx_count
    @required_confirms = required_confirms
    @manually_selected_outpoints = manually_selected_outpoints
  end

  def ==(other)
    if @send_amount != other.send_amount
      return false
    end
    if @maker_count != other.maker_count
      return false
    end
    if @tx_count != other.tx_count
      return false
    end
    if @required_confirms != other.required_confirms
      return false
    end
    if @manually_selected_outpoints != other.manually_selected_outpoints
      return false
    end

    true
  end
end
  
  # Record type TotalUtxoInfo
class TotalUtxoInfo
  attr_reader :list_unspent_result_entry, :utxo_spend_info

  def initialize(list_unspent_result_entry:, utxo_spend_info:)
    @list_unspent_result_entry = list_unspent_result_entry
    @utxo_spend_info = utxo_spend_info
  end

  def ==(other)
    if @list_unspent_result_entry != other.list_unspent_result_entry
      return false
    end
    if @utxo_spend_info != other.utxo_spend_info
      return false
    end

    true
  end
end
  
  # Record type Txid
class Txid
  attr_reader :value

  def initialize(value:)
    @value = value
  end

  def ==(other)
    if @value != other.value
      return false
    end

    true
  end
end
  
  # Record type UtxoSpendInfo
class UtxoSpendInfo
  attr_reader :spend_type, :path, :multisig_redeemscript, :input_value, :index, :original_multisig_redeemscript

  def initialize(spend_type:, path:, multisig_redeemscript:, input_value:, index:, original_multisig_redeemscript:)
    @spend_type = spend_type
    @path = path
    @multisig_redeemscript = multisig_redeemscript
    @input_value = input_value
    @index = index
    @original_multisig_redeemscript = original_multisig_redeemscript
  end

  def ==(other)
    if @spend_type != other.spend_type
      return false
    end
    if @path != other.path
      return false
    end
    if @multisig_redeemscript != other.multisig_redeemscript
      return false
    end
    if @input_value != other.input_value
      return false
    end
    if @index != other.index
      return false
    end
    if @original_multisig_redeemscript != other.original_multisig_redeemscript
      return false
    end

    true
  end
end
  
  # Record type UtxoWithAddress
class UtxoWithAddress
  attr_reader :amount, :address

  def initialize(amount:, address:)
    @amount = amount
    @address = address
  end

  def ==(other)
    if @amount != other.amount
      return false
    end
    if @address != other.address
      return false
    end

    true
  end
end
  
  # Record type WalletTxInfo
class WalletTxInfo
  attr_reader :confirmations, :blockhash, :blockindex, :blocktime, :blockheight, :txid, :time, :timereceived, :bip125_replaceable, :wallet_conflicts

  def initialize(confirmations:, blockhash:, blockindex:, blocktime:, blockheight:, txid:, time:, timereceived:, bip125_replaceable:, wallet_conflicts:)
    @confirmations = confirmations
    @blockhash = blockhash
    @blockindex = blockindex
    @blocktime = blocktime
    @blockheight = blockheight
    @txid = txid
    @time = time
    @timereceived = timereceived
    @bip125_replaceable = bip125_replaceable
    @wallet_conflicts = wallet_conflicts
  end

  def ==(other)
    if @confirmations != other.confirmations
      return false
    end
    if @blockhash != other.blockhash
      return false
    end
    if @blockindex != other.blockindex
      return false
    end
    if @blocktime != other.blocktime
      return false
    end
    if @blockheight != other.blockheight
      return false
    end
    if @txid != other.txid
      return false
    end
    if @time != other.time
      return false
    end
    if @timereceived != other.timereceived
      return false
    end
    if @bip125_replaceable != other.bip125_replaceable
      return false
    end
    if @wallet_conflicts != other.wallet_conflicts
      return false
    end

    true
  end
end
  

  
  

def self.create_default_rpc_config()
  result = Coinswap.rust_call(:uniffi_coinswap_ffi_fn_func_create_default_rpc_config,)
  return result.consumeIntoTypeRpcConfig
end


  
  

def self.fetch_mempool_fees()
  result = Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_func_fetch_mempool_fees,)
  return result.consumeIntoTypeFeeRates
end


  
  

def self.is_wallet_encrypted(wallet_path)
    wallet_path = Coinswap::uniffi_utf8(wallet_path)
    
    
  result = Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_func_is_wallet_encrypted,RustBuffer.allocFromString(wallet_path))
  return 1 == result
end


  
  

def self.restore_wallet_gui_app(data_dir, wallet_file_name, rpc_config, backup_file_path, password)
    data_dir = (data_dir ? Coinswap::uniffi_utf8(data_dir) : nil)
    RustBuffer.check_lower_Optionalstring(data_dir)
    
    wallet_file_name = (wallet_file_name ? Coinswap::uniffi_utf8(wallet_file_name) : nil)
    RustBuffer.check_lower_Optionalstring(wallet_file_name)
    
    rpc_config = rpc_config
    RustBuffer.check_lower_TypeRpcConfig(rpc_config)
    
    backup_file_path = Coinswap::uniffi_utf8(backup_file_path)
    
    
    password = (password ? Coinswap::uniffi_utf8(password) : nil)
    RustBuffer.check_lower_Optionalstring(password)
    
  Coinswap.rust_call(:uniffi_coinswap_ffi_fn_func_restore_wallet_gui_app,RustBuffer.alloc_from_Optionalstring(data_dir),RustBuffer.alloc_from_Optionalstring(wallet_file_name),RustBuffer.alloc_from_TypeRpcConfig(rpc_config),RustBuffer.allocFromString(backup_file_path),RustBuffer.alloc_from_Optionalstring(password))
end

  
  

def self.setup_logging(data_dir)
    data_dir = (data_dir ? Coinswap::uniffi_utf8(data_dir) : nil)
    RustBuffer.check_lower_Optionalstring(data_dir)
    
  Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_func_setup_logging,RustBuffer.alloc_from_Optionalstring(data_dir))
end

  

  
  class Taker

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self.uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self.uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Coinswap.rust_call(
        :uniffi_coinswap_ffi_fn_free_taker,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self.uniffi_check_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a Taker instance, got #{inst}"
    end
  end

  def uniffi_clone_pointer()
    return Coinswap.rust_call(
      :uniffi_coinswap_ffi_fn_clone_taker,
      @pointer
    )
  end

  def self.uniffi_lower(inst)
    return inst.uniffi_clone_pointer()
  end

  def self.init(data_dir, wallet_file_name, rpc_config, control_port, tor_auth_password, zmq_addr, password)
        data_dir = (data_dir ? Coinswap::uniffi_utf8(data_dir) : nil)
        RustBuffer.check_lower_Optionalstring(data_dir)
        wallet_file_name = (wallet_file_name ? Coinswap::uniffi_utf8(wallet_file_name) : nil)
        RustBuffer.check_lower_Optionalstring(wallet_file_name)
        rpc_config = (rpc_config ? rpc_config : nil)
        RustBuffer.check_lower_OptionalTypeRpcConfig(rpc_config)
        control_port = (control_port ? Coinswap::uniffi_in_range(control_port, "u16", 0, 2**16) : nil)
        RustBuffer.check_lower_Optionalu16(control_port)
        tor_auth_password = (tor_auth_password ? Coinswap::uniffi_utf8(tor_auth_password) : nil)
        RustBuffer.check_lower_Optionalstring(tor_auth_password)
        zmq_addr = Coinswap::uniffi_utf8(zmq_addr)
        
        password = (password ? Coinswap::uniffi_utf8(password) : nil)
        RustBuffer.check_lower_Optionalstring(password)
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return uniffi_allocate(Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_constructor_taker_init,RustBuffer.alloc_from_Optionalstring(data_dir),RustBuffer.alloc_from_Optionalstring(wallet_file_name),RustBuffer.alloc_from_OptionalTypeRpcConfig(rpc_config),RustBuffer.alloc_from_Optionalu16(control_port),RustBuffer.alloc_from_Optionalstring(tor_auth_password),RustBuffer.allocFromString(zmq_addr),RustBuffer.alloc_from_Optionalstring(password)))
  end
  

  def backup(destination_path, password)
        destination_path = Coinswap::uniffi_utf8(destination_path)
        
        password = (password ? Coinswap::uniffi_utf8(password) : nil)
        RustBuffer.check_lower_Optionalstring(password)
      Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taker_backup,uniffi_clone_pointer(),RustBuffer.allocFromString(destination_path),RustBuffer.alloc_from_Optionalstring(password))
  end
  
  def display_offer(maker_offer)
        maker_offer = maker_offer
        RustBuffer.check_lower_TypeOffer(maker_offer)
    result = Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taker_display_offer,uniffi_clone_pointer(),RustBuffer.alloc_from_TypeOffer(maker_offer))
    return result.consumeIntoString
  end
  def do_coinswap(swap_params)
        swap_params = swap_params
        RustBuffer.check_lower_TypeSwapParams(swap_params)
    result = Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taker_do_coinswap,uniffi_clone_pointer(),RustBuffer.alloc_from_TypeSwapParams(swap_params))
    return result.consumeIntoOptionalTypeSwapReport
  end
  def fetch_all_makers()
    result = Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taker_fetch_all_makers,uniffi_clone_pointer(),)
    return result.consumeIntoSequencestring
  end
  def fetch_good_makers()
    result = Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taker_fetch_good_makers,uniffi_clone_pointer(),)
    return result.consumeIntoSequencestring
  end
  def fetch_offers()
    result = Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taker_fetch_offers,uniffi_clone_pointer(),)
    return result.consumeIntoTypeOfferBook
  end
  def get_all_good_makers()
    result = Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taker_get_all_good_makers,uniffi_clone_pointer(),)
    return result.consumeIntoSequencestring
  end
  def get_balances()
    result = Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taker_get_balances,uniffi_clone_pointer(),)
    return result.consumeIntoTypeBalances
  end
  def get_next_external_address()
    result = Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taker_get_next_external_address,uniffi_clone_pointer(),)
    return result.consumeIntoTypeAddress
  end
  def get_next_internal_addresses(count)
        count = Coinswap::uniffi_in_range(count, "u32", 0, 2**32)
        
    result = Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taker_get_next_internal_addresses,uniffi_clone_pointer(),count)
    return result.consumeIntoSequenceTypeAddress
  end
  def get_transactions(count, skip)
        count = (count ? Coinswap::uniffi_in_range(count, "u32", 0, 2**32) : nil)
        RustBuffer.check_lower_Optionalu32(count)
        skip = (skip ? Coinswap::uniffi_in_range(skip, "u32", 0, 2**32) : nil)
        RustBuffer.check_lower_Optionalu32(skip)
    result = Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taker_get_transactions,uniffi_clone_pointer(),RustBuffer.alloc_from_Optionalu32(count),RustBuffer.alloc_from_Optionalu32(skip))
    return result.consumeIntoSequenceTypeListTransactionResult
  end
  def get_wallet_name()
    result = Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taker_get_wallet_name,uniffi_clone_pointer(),)
    return result.consumeIntoString
  end
  def list_all_utxo_spend_info()
    result = Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taker_list_all_utxo_spend_info,uniffi_clone_pointer(),)
    return result.consumeIntoSequenceTypeTotalUtxoInfo
  end
  def lock_unspendable_utxos()
      Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taker_lock_unspendable_utxos,uniffi_clone_pointer(),)
  end
  
  def recover_from_swap()
      Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taker_recover_from_swap,uniffi_clone_pointer(),)
  end
  
  def send_to_address(address, amount, fee_rate, manually_selected_outpoints)
        address = Coinswap::uniffi_utf8(address)
        
        amount = Coinswap::uniffi_in_range(amount, "i64", -2**63, 2**63)
        
        fee_rate = (fee_rate ? fee_rate : nil)
        RustBuffer.check_lower_Optionalf64(fee_rate)
        manually_selected_outpoints = (manually_selected_outpoints ? manually_selected_outpoints : nil)
        RustBuffer.check_lower_OptionalSequenceTypeOutPoint(manually_selected_outpoints)
    result = Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taker_send_to_address,uniffi_clone_pointer(),RustBuffer.allocFromString(address),amount,RustBuffer.alloc_from_Optionalf64(fee_rate),RustBuffer.alloc_from_OptionalSequenceTypeOutPoint(manually_selected_outpoints))
    return result.consumeIntoString
  end
  def sync_and_save()
      Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taker_sync_and_save,uniffi_clone_pointer(),)
  end
  
  def sync_offerbook()
      Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taker_sync_offerbook,uniffi_clone_pointer(),)
  end
  
  
end
  
  class TaprootTaker

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self.uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self.uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Coinswap.rust_call(
        :uniffi_coinswap_ffi_fn_free_taproottaker,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self.uniffi_check_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a TaprootTaker instance, got #{inst}"
    end
  end

  def uniffi_clone_pointer()
    return Coinswap.rust_call(
      :uniffi_coinswap_ffi_fn_clone_taproottaker,
      @pointer
    )
  end

  def self.uniffi_lower(inst)
    return inst.uniffi_clone_pointer()
  end

  def self.init(data_dir, wallet_file_name, rpc_config, control_port, tor_auth_password, zmq_addr, password)
        data_dir = (data_dir ? Coinswap::uniffi_utf8(data_dir) : nil)
        RustBuffer.check_lower_Optionalstring(data_dir)
        wallet_file_name = (wallet_file_name ? Coinswap::uniffi_utf8(wallet_file_name) : nil)
        RustBuffer.check_lower_Optionalstring(wallet_file_name)
        rpc_config = (rpc_config ? rpc_config : nil)
        RustBuffer.check_lower_OptionalTypeRpcConfig(rpc_config)
        control_port = (control_port ? Coinswap::uniffi_in_range(control_port, "u16", 0, 2**16) : nil)
        RustBuffer.check_lower_Optionalu16(control_port)
        tor_auth_password = (tor_auth_password ? Coinswap::uniffi_utf8(tor_auth_password) : nil)
        RustBuffer.check_lower_Optionalstring(tor_auth_password)
        zmq_addr = Coinswap::uniffi_utf8(zmq_addr)
        
        password = (password ? Coinswap::uniffi_utf8(password) : nil)
        RustBuffer.check_lower_Optionalstring(password)
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return uniffi_allocate(Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_constructor_taproottaker_init,RustBuffer.alloc_from_Optionalstring(data_dir),RustBuffer.alloc_from_Optionalstring(wallet_file_name),RustBuffer.alloc_from_OptionalTypeRpcConfig(rpc_config),RustBuffer.alloc_from_Optionalu16(control_port),RustBuffer.alloc_from_Optionalstring(tor_auth_password),RustBuffer.allocFromString(zmq_addr),RustBuffer.alloc_from_Optionalstring(password)))
  end
  

  def backup(destination_path, password)
        destination_path = Coinswap::uniffi_utf8(destination_path)
        
        password = (password ? Coinswap::uniffi_utf8(password) : nil)
        RustBuffer.check_lower_Optionalstring(password)
      Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taproottaker_backup,uniffi_clone_pointer(),RustBuffer.allocFromString(destination_path),RustBuffer.alloc_from_Optionalstring(password))
  end
  
  def display_offer(maker_offer)
        maker_offer = maker_offer
        RustBuffer.check_lower_TypeOffer(maker_offer)
    result = Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taproottaker_display_offer,uniffi_clone_pointer(),RustBuffer.alloc_from_TypeOffer(maker_offer))
    return result.consumeIntoString
  end
  def do_coinswap(swap_params)
        swap_params = swap_params
        RustBuffer.check_lower_TypeTaprootSwapParams(swap_params)
    result = Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taproottaker_do_coinswap,uniffi_clone_pointer(),RustBuffer.alloc_from_TypeTaprootSwapParams(swap_params))
    return result.consumeIntoOptionalTypeSwapReport
  end
  def fetch_all_makers()
    result = Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taproottaker_fetch_all_makers,uniffi_clone_pointer(),)
    return result.consumeIntoSequencestring
  end
  def fetch_good_makers()
    result = Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taproottaker_fetch_good_makers,uniffi_clone_pointer(),)
    return result.consumeIntoSequencestring
  end
  def fetch_offers()
    result = Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taproottaker_fetch_offers,uniffi_clone_pointer(),)
    return result.consumeIntoTypeOfferBook
  end
  def get_all_good_makers()
    result = Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taproottaker_get_all_good_makers,uniffi_clone_pointer(),)
    return result.consumeIntoSequencestring
  end
  def get_balances()
    result = Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taproottaker_get_balances,uniffi_clone_pointer(),)
    return result.consumeIntoTypeBalances
  end
  def get_next_external_address()
    result = Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taproottaker_get_next_external_address,uniffi_clone_pointer(),)
    return result.consumeIntoTypeAddress
  end
  def get_next_internal_addresses(count)
        count = Coinswap::uniffi_in_range(count, "u32", 0, 2**32)
        
    result = Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taproottaker_get_next_internal_addresses,uniffi_clone_pointer(),count)
    return result.consumeIntoSequenceTypeAddress
  end
  def get_transactions(count, skip)
        count = (count ? Coinswap::uniffi_in_range(count, "u32", 0, 2**32) : nil)
        RustBuffer.check_lower_Optionalu32(count)
        skip = (skip ? Coinswap::uniffi_in_range(skip, "u32", 0, 2**32) : nil)
        RustBuffer.check_lower_Optionalu32(skip)
    result = Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taproottaker_get_transactions,uniffi_clone_pointer(),RustBuffer.alloc_from_Optionalu32(count),RustBuffer.alloc_from_Optionalu32(skip))
    return result.consumeIntoSequenceTypeListTransactionResult
  end
  def get_wallet_name()
    result = Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taproottaker_get_wallet_name,uniffi_clone_pointer(),)
    return result.consumeIntoString
  end
  def list_all_utxo_spend_info()
    result = Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taproottaker_list_all_utxo_spend_info,uniffi_clone_pointer(),)
    return result.consumeIntoSequenceTypeTotalUtxoInfo
  end
  def lock_unspendable_utxos()
      Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taproottaker_lock_unspendable_utxos,uniffi_clone_pointer(),)
  end
  
  def recover_from_swap()
      Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taproottaker_recover_from_swap,uniffi_clone_pointer(),)
  end
  
  def send_to_address(address, amount, fee_rate, manually_selected_outpoints)
        address = Coinswap::uniffi_utf8(address)
        
        amount = Coinswap::uniffi_in_range(amount, "i64", -2**63, 2**63)
        
        fee_rate = (fee_rate ? fee_rate : nil)
        RustBuffer.check_lower_Optionalf64(fee_rate)
        manually_selected_outpoints = (manually_selected_outpoints ? manually_selected_outpoints : nil)
        RustBuffer.check_lower_OptionalSequenceTypeOutPoint(manually_selected_outpoints)
    result = Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taproottaker_send_to_address,uniffi_clone_pointer(),RustBuffer.allocFromString(address),amount,RustBuffer.alloc_from_Optionalf64(fee_rate),RustBuffer.alloc_from_OptionalSequenceTypeOutPoint(manually_selected_outpoints))
    return result.consumeIntoString
  end
  def sync_and_save()
      Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taproottaker_sync_and_save,uniffi_clone_pointer(),)
  end
  
  def sync_offerbook()
      Coinswap.rust_call_with_error(TakerError,:uniffi_coinswap_ffi_fn_method_taproottaker_sync_offerbook,uniffi_clone_pointer(),)
  end
  
  
end
  
end

