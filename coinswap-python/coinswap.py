# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

from __future__ import annotations
import os
import sys
import ctypes
from dataclasses import dataclass
import enum
import struct
import contextlib
import datetime
import threading
import itertools
import traceback
import typing
import platform


# Used for default argument values
_DEFAULT = object() # type: typing.Any


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_uint64),
        ("len", ctypes.c_uint64),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def default():
        return _UniffiRustBuffer(0, 0, None)

    @staticmethod
    def alloc(size):
        return _uniffi_rust_call(_UniffiLib.ffi_coinswap_ffi_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _uniffi_rust_call(_UniffiLib.ffi_coinswap_ffi_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return _uniffi_rust_call(_UniffiLib.ffi_coinswap_ffi_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError(f"junk data left in buffer at end of consume_with_stream {s.remaining()}")
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError(f"junk data left in buffer at end of read_with_stream {s.remaining()}")

class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_UNEXPECTED_ERROR = 2

    @staticmethod
    def default():
        return _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer.default())

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
            return "_UniffiRustCallStatus(CALL_UNEXPECTED_ERROR)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"

def _uniffi_rust_call(fn, *args):
    # Call a rust function
    return _uniffi_rust_call_with_error(None, fn, *args)

def _uniffi_rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus.default()

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("_uniffi_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiFfiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
            call_status.code))

def _uniffi_trait_interface_call(call_status, make_call, write_return_value):
    try:
        return write_return_value(make_call())
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiFfiConverterString.lower(repr(e))

def _uniffi_trait_interface_call_with_error(call_status, make_call, write_return_value, error_type, lower_error):
    try:
        try:
            return write_return_value(make_call())
        except error_type as e:
            call_status.code = _UniffiRustCallStatus.CALL_ERROR
            call_status.error_buf = lower_error(e)
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiFfiConverterString.lower(repr(e))
# Initial value and increment amount for handles. 
# These ensure that Python-generated handles always have the lowest bit set
_UNIFFI_HANDLEMAP_INITIAL = 1
_UNIFFI_HANDLEMAP_DELTA = 2

class _UniffiHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._map = {}  # type: Dict[Handle, Any]
        self._lock = threading.Lock()
        self._counter = _UNIFFI_HANDLEMAP_INITIAL

    def insert(self, obj):
        with self._lock:
            return self._insert(obj)

    """Low-level insert, this assumes `self._lock` is held."""
    def _insert(self, obj):
        handle = self._counter
        self._counter += _UNIFFI_HANDLEMAP_DELTA
        self._map[handle] = obj
        return handle

    def get(self, handle):
        try:
            with self._lock:
                return self._map[handle]
        except KeyError:
            raise InternalError(f"_UniffiHandleMap.get: Invalid handle {handle}")

    def clone(self, handle):
        try:
            with self._lock:
                obj = self._map[handle]
                return self._insert(obj)
        except KeyError:
            raise InternalError(f"_UniffiHandleMap.clone: Invalid handle {handle}")

    def remove(self, handle):
        try:
            with self._lock:
                return self._map.pop(handle)
        except KeyError:
            raise InternalError(f"_UniffiHandleMap.remove: Invalid handle: {handle}")

    def __len__(self):
        return len(self._map)
# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return value

class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))

class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))

# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)

def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_uint64, return_type, _UniffiRustCallStatus)

def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("coinswap_ffi")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 30
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_coinswap_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def _uniffi_check_api_checksums(lib):
    if lib.uniffi_coinswap_ffi_checksum_func_create_default_rpc_config() != 9423:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_func_fetch_mempool_fees() != 24485:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_func_is_wallet_encrypted() != 41459:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_func_restore_wallet_gui_app() != 58018:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_func_setup_logging() != 49824:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_constructor_taker_init() != 58322:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_backup() != 54791:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_display_offer() != 3495:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_do_coinswap() != 30300:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_fetch_all_makers() != 10547:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_fetch_offers() != 57730:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_get_balances() != 61330:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_get_next_external_address() != 37354:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_get_next_internal_addresses() != 19334:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_get_transactions() != 59237:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_get_wallet_name() != 45636:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_is_offerbook_syncing() != 63584:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_list_all_utxo_spend_info() != 28116:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_lock_unspendable_utxos() != 12155:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_recover_from_swap() != 45555:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_run_offer_sync_now() != 62130:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_send_to_address() != 17485:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_setup_logging() != 11119:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taker_sync_and_save() != 9097:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_constructor_taproottaker_init() != 33076:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taproottaker_backup() != 14546:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taproottaker_display_offer() != 39258:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taproottaker_do_coinswap() != 19818:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taproottaker_fetch_all_makers() != 51619:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taproottaker_fetch_offers() != 34915:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taproottaker_get_balances() != 61569:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taproottaker_get_next_external_address() != 49385:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taproottaker_get_next_internal_addresses() != 39200:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taproottaker_get_transactions() != 17891:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taproottaker_get_wallet_name() != 51305:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taproottaker_is_offerbook_syncing() != 50580:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taproottaker_list_all_utxo_spend_info() != 14333:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taproottaker_lock_unspendable_utxos() != 41043:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taproottaker_recover_from_swap() != 32296:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taproottaker_run_offer_sync_now() != 9519:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taproottaker_send_to_address() != 36184:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taproottaker_setup_logging() != 45279:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_coinswap_ffi_checksum_method_taproottaker_sync_and_save() != 24360:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UniffiLib.ffi_coinswap_ffi_rustbuffer_alloc.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_coinswap_ffi_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_coinswap_ffi_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_coinswap_ffi_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_coinswap_ffi_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_coinswap_ffi_rustbuffer_free.restype = None
_UniffiLib.ffi_coinswap_ffi_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_coinswap_ffi_rustbuffer_reserve.restype = _UniffiRustBuffer
_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_int8,
)
_UNIFFI_FOREIGN_FUTURE_DROPPED_CALLBACK = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
class _UniffiForeignFutureDroppedCallbackStruct(ctypes.Structure):
    _fields_ = [
        ("handle", ctypes.c_uint64),
        ("free", _UNIFFI_FOREIGN_FUTURE_DROPPED_CALLBACK),
    ]
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_u8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_u8.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_u8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_u8.restype = ctypes.c_uint8
_UniffiLib.ffi_coinswap_ffi_rust_future_free_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_free_u8.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_i8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_i8.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_i8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_i8.restype = ctypes.c_int8
_UniffiLib.ffi_coinswap_ffi_rust_future_free_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_free_i8.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_u16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_u16.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_u16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_u16.restype = ctypes.c_uint16
_UniffiLib.ffi_coinswap_ffi_rust_future_free_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_free_u16.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_i16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_i16.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_i16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_i16.restype = ctypes.c_int16
_UniffiLib.ffi_coinswap_ffi_rust_future_free_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_free_i16.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_u32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_u32.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_u32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_u32.restype = ctypes.c_uint32
_UniffiLib.ffi_coinswap_ffi_rust_future_free_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_free_u32.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_i32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_i32.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_i32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_i32.restype = ctypes.c_int32
_UniffiLib.ffi_coinswap_ffi_rust_future_free_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_free_i32.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_u64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_u64.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_u64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_u64.restype = ctypes.c_uint64
_UniffiLib.ffi_coinswap_ffi_rust_future_free_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_free_u64.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_i64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_i64.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_i64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_i64.restype = ctypes.c_int64
_UniffiLib.ffi_coinswap_ffi_rust_future_free_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_free_i64.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_f32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_f32.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_f32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_f32.restype = ctypes.c_float
_UniffiLib.ffi_coinswap_ffi_rust_future_free_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_free_f32.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_f64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_f64.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_f64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_f64.restype = ctypes.c_double
_UniffiLib.ffi_coinswap_ffi_rust_future_free_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_free_f64.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_rust_buffer.restype = _UniffiRustBuffer
_UniffiLib.ffi_coinswap_ffi_rust_future_free_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_void.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_poll_void.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_cancel_void.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_void.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_coinswap_ffi_rust_future_complete_void.restype = None
_UniffiLib.ffi_coinswap_ffi_rust_future_free_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_coinswap_ffi_rust_future_free_void.restype = None
_UniffiLib.uniffi_coinswap_ffi_fn_clone_taker.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_clone_taker.restype = ctypes.c_uint64
_UniffiLib.uniffi_coinswap_ffi_fn_free_taker.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_free_taker.restype = None
_UniffiLib.uniffi_coinswap_ffi_fn_clone_taproottaker.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_clone_taproottaker.restype = ctypes.c_uint64
_UniffiLib.uniffi_coinswap_ffi_fn_free_taproottaker.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_free_taproottaker.restype = None
_UniffiLib.uniffi_coinswap_ffi_fn_func_create_default_rpc_config.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_func_create_default_rpc_config.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_func_fetch_mempool_fees.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_func_fetch_mempool_fees.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_func_is_wallet_encrypted.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_func_is_wallet_encrypted.restype = ctypes.c_int8
_UniffiLib.uniffi_coinswap_ffi_fn_func_restore_wallet_gui_app.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_func_restore_wallet_gui_app.restype = None
_UniffiLib.uniffi_coinswap_ffi_fn_func_setup_logging.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_func_setup_logging.restype = None
_UniffiLib.uniffi_coinswap_ffi_fn_constructor_taker_init.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_constructor_taker_init.restype = ctypes.c_uint64
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_backup.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_backup.restype = None
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_display_offer.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_display_offer.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_do_coinswap.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_do_coinswap.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_fetch_all_makers.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_fetch_all_makers.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_fetch_offers.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_fetch_offers.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_get_balances.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_get_balances.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_get_next_external_address.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_get_next_external_address.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_get_next_internal_addresses.argtypes = (
    ctypes.c_uint64,
    ctypes.c_uint32,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_get_next_internal_addresses.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_get_transactions.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_get_transactions.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_get_wallet_name.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_get_wallet_name.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_is_offerbook_syncing.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_is_offerbook_syncing.restype = ctypes.c_int8
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_list_all_utxo_spend_info.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_list_all_utxo_spend_info.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_lock_unspendable_utxos.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_lock_unspendable_utxos.restype = None
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_recover_from_swap.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_recover_from_swap.restype = None
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_run_offer_sync_now.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_run_offer_sync_now.restype = None
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_send_to_address.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.c_int64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_send_to_address.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_setup_logging.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_setup_logging.restype = None
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_sync_and_save.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taker_sync_and_save.restype = None
_UniffiLib.uniffi_coinswap_ffi_fn_constructor_taproottaker_init.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_constructor_taproottaker_init.restype = ctypes.c_uint64
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_backup.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_backup.restype = None
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_display_offer.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_display_offer.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_do_coinswap.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_do_coinswap.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_fetch_all_makers.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_fetch_all_makers.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_fetch_offers.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_fetch_offers.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_get_balances.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_get_balances.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_get_next_external_address.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_get_next_external_address.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_get_next_internal_addresses.argtypes = (
    ctypes.c_uint64,
    ctypes.c_uint32,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_get_next_internal_addresses.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_get_transactions.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_get_transactions.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_get_wallet_name.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_get_wallet_name.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_is_offerbook_syncing.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_is_offerbook_syncing.restype = ctypes.c_int8
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_list_all_utxo_spend_info.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_list_all_utxo_spend_info.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_lock_unspendable_utxos.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_lock_unspendable_utxos.restype = None
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_recover_from_swap.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_recover_from_swap.restype = None
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_run_offer_sync_now.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_run_offer_sync_now.restype = None
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_send_to_address.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.c_int64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_send_to_address.restype = _UniffiRustBuffer
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_setup_logging.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_setup_logging.restype = None
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_sync_and_save.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_sync_and_save.restype = None
_UniffiLib.ffi_coinswap_ffi_uniffi_contract_version.argtypes = (
)
_UniffiLib.ffi_coinswap_ffi_uniffi_contract_version.restype = ctypes.c_uint32
_UniffiLib.uniffi_coinswap_ffi_checksum_func_create_default_rpc_config.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_func_create_default_rpc_config.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_func_fetch_mempool_fees.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_func_fetch_mempool_fees.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_func_is_wallet_encrypted.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_func_is_wallet_encrypted.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_func_restore_wallet_gui_app.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_func_restore_wallet_gui_app.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_func_setup_logging.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_func_setup_logging.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_constructor_taker_init.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_constructor_taker_init.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_backup.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_backup.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_display_offer.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_display_offer.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_do_coinswap.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_do_coinswap.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_fetch_all_makers.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_fetch_all_makers.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_fetch_offers.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_fetch_offers.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_get_balances.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_get_balances.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_get_next_external_address.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_get_next_external_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_get_next_internal_addresses.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_get_next_internal_addresses.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_get_transactions.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_get_transactions.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_get_wallet_name.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_get_wallet_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_is_offerbook_syncing.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_is_offerbook_syncing.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_list_all_utxo_spend_info.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_list_all_utxo_spend_info.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_lock_unspendable_utxos.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_lock_unspendable_utxos.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_recover_from_swap.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_recover_from_swap.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_run_offer_sync_now.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_run_offer_sync_now.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_send_to_address.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_send_to_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_setup_logging.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_setup_logging.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_sync_and_save.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taker_sync_and_save.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_constructor_taproottaker_init.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_constructor_taproottaker_init.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_backup.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_backup.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_display_offer.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_display_offer.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_do_coinswap.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_do_coinswap.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_fetch_all_makers.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_fetch_all_makers.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_fetch_offers.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_fetch_offers.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_get_balances.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_get_balances.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_get_next_external_address.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_get_next_external_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_get_next_internal_addresses.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_get_next_internal_addresses.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_get_transactions.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_get_transactions.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_get_wallet_name.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_get_wallet_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_is_offerbook_syncing.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_is_offerbook_syncing.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_list_all_utxo_spend_info.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_list_all_utxo_spend_info.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_lock_unspendable_utxos.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_lock_unspendable_utxos.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_recover_from_swap.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_recover_from_swap.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_run_offer_sync_now.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_run_offer_sync_now.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_send_to_address.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_send_to_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_setup_logging.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_setup_logging.restype = ctypes.c_uint16
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_sync_and_save.argtypes = (
)
_UniffiLib.uniffi_coinswap_ffi_checksum_method_taproottaker_sync_and_save.restype = ctypes.c_uint16

_uniffi_check_contract_api_version(_UniffiLib)
# _uniffi_check_api_checksums(_UniffiLib)



# Public interface members begin here.


class _UniffiFfiConverterString:
    @staticmethod
    def check_lower(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()

@dataclass
class Address:
    def __init__(self, *, address:str):
        self.address = address
        
        

    
    def __str__(self):
        return "Address(address={})".format(self.address)
    def __eq__(self, other):
        if self.address != other.address:
            return False
        return True

class _UniffiFfiConverterTypeAddress(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Address(
            address=_UniffiFfiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.address)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.address, buf)

@dataclass
class AddressType:
    def __init__(self, *, addr_type:str):
        self.addr_type = addr_type
        
        

    
    def __str__(self):
        return "AddressType(addr_type={})".format(self.addr_type)
    def __eq__(self, other):
        if self.addr_type != other.addr_type:
            return False
        return True

class _UniffiFfiConverterTypeAddressType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AddressType(
            addr_type=_UniffiFfiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.addr_type)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.addr_type, buf)

class _UniffiFfiConverterInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i64"
    VALUE_MIN = -2**63
    VALUE_MAX = 2**63

    @staticmethod
    def read(buf):
        return buf.read_i64()

    @staticmethod
    def write(value, buf):
        buf.write_i64(value)

@dataclass
class Amount:
    def __init__(self, *, sats:int):
        self.sats = sats
        
        

    
    def __str__(self):
        return "Amount(sats={})".format(self.sats)
    def __eq__(self, other):
        if self.sats != other.sats:
            return False
        return True

class _UniffiFfiConverterTypeAmount(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Amount(
            sats=_UniffiFfiConverterInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterInt64.check_lower(value.sats)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterInt64.write(value.sats, buf)

@dataclass
class Balances:
    def __init__(self, *, regular:int, swap:int, contract:int, fidelity:int, spendable:int):
        self.regular = regular
        self.swap = swap
        self.contract = contract
        self.fidelity = fidelity
        self.spendable = spendable
        
        

    
    def __str__(self):
        return "Balances(regular={}, swap={}, contract={}, fidelity={}, spendable={})".format(self.regular, self.swap, self.contract, self.fidelity, self.spendable)
    def __eq__(self, other):
        if self.regular != other.regular:
            return False
        if self.swap != other.swap:
            return False
        if self.contract != other.contract:
            return False
        if self.fidelity != other.fidelity:
            return False
        if self.spendable != other.spendable:
            return False
        return True

class _UniffiFfiConverterTypeBalances(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Balances(
            regular=_UniffiFfiConverterInt64.read(buf),
            swap=_UniffiFfiConverterInt64.read(buf),
            contract=_UniffiFfiConverterInt64.read(buf),
            fidelity=_UniffiFfiConverterInt64.read(buf),
            spendable=_UniffiFfiConverterInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterInt64.check_lower(value.regular)
        _UniffiFfiConverterInt64.check_lower(value.swap)
        _UniffiFfiConverterInt64.check_lower(value.contract)
        _UniffiFfiConverterInt64.check_lower(value.fidelity)
        _UniffiFfiConverterInt64.check_lower(value.spendable)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterInt64.write(value.regular, buf)
        _UniffiFfiConverterInt64.write(value.swap, buf)
        _UniffiFfiConverterInt64.write(value.contract, buf)
        _UniffiFfiConverterInt64.write(value.fidelity, buf)
        _UniffiFfiConverterInt64.write(value.spendable, buf)

class _UniffiFfiConverterFloat64(_UniffiConverterPrimitiveFloat):
    @staticmethod
    def read(buf):
        return buf.read_double()

    @staticmethod
    def write(value, buf):
        buf.write_double(value)

@dataclass
class FeeRates:
    def __init__(self, *, fastest:float, standard:float, economy:float):
        self.fastest = fastest
        self.standard = standard
        self.economy = economy
        
        

    
    def __str__(self):
        return "FeeRates(fastest={}, standard={}, economy={})".format(self.fastest, self.standard, self.economy)
    def __eq__(self, other):
        if self.fastest != other.fastest:
            return False
        if self.standard != other.standard:
            return False
        if self.economy != other.economy:
            return False
        return True

class _UniffiFfiConverterTypeFeeRates(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FeeRates(
            fastest=_UniffiFfiConverterFloat64.read(buf),
            standard=_UniffiFfiConverterFloat64.read(buf),
            economy=_UniffiFfiConverterFloat64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterFloat64.check_lower(value.fastest)
        _UniffiFfiConverterFloat64.check_lower(value.standard)
        _UniffiFfiConverterFloat64.check_lower(value.economy)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterFloat64.write(value.fastest, buf)
        _UniffiFfiConverterFloat64.write(value.standard, buf)
        _UniffiFfiConverterFloat64.write(value.economy, buf)

class _UniffiFfiConverterUInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u32"
    VALUE_MIN = 0
    VALUE_MAX = 2**32

    @staticmethod
    def read(buf):
        return buf.read_u32()

    @staticmethod
    def write(value, buf):
        buf.write_u32(value)

@dataclass
class LockTime:
    def __init__(self, *, lock_type:str, value:int):
        self.lock_type = lock_type
        self.value = value
        
        

    
    def __str__(self):
        return "LockTime(lock_type={}, value={})".format(self.lock_type, self.value)
    def __eq__(self, other):
        if self.lock_type != other.lock_type:
            return False
        if self.value != other.value:
            return False
        return True

class _UniffiFfiConverterTypeLockTime(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LockTime(
            lock_type=_UniffiFfiConverterString.read(buf),
            value=_UniffiFfiConverterUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.lock_type)
        _UniffiFfiConverterUInt32.check_lower(value.value)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.lock_type, buf)
        _UniffiFfiConverterUInt32.write(value.value, buf)

class _UniffiFfiConverterBoolean:
    @classmethod
    def check_lower(cls, value):
        return not not value

    @classmethod
    def lower(cls, value):
        return 1 if value else 0

    @staticmethod
    def lift(value):
        return value != 0

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write(cls, value, buf):
        buf.write_u8(value)

class _UniffiFfiConverterBytes(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative byte string length")
        return buf.read(size)

    @staticmethod
    def check_lower(value):
        try:
            memoryview(value)
        except TypeError:
            raise TypeError("a bytes-like object is required, not {!r}".format(type(value).__name__))

    @staticmethod
    def write(value, buf):
        buf.write_i32(len(value))
        buf.write(value)

@dataclass
class PublicKey:
    def __init__(self, *, compressed:bool, inner:bytes):
        self.compressed = compressed
        self.inner = inner
        
        

    
    def __str__(self):
        return "PublicKey(compressed={}, inner={})".format(self.compressed, self.inner)
    def __eq__(self, other):
        if self.compressed != other.compressed:
            return False
        if self.inner != other.inner:
            return False
        return True

class _UniffiFfiConverterTypePublicKey(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PublicKey(
            compressed=_UniffiFfiConverterBoolean.read(buf),
            inner=_UniffiFfiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterBoolean.check_lower(value.compressed)
        _UniffiFfiConverterBytes.check_lower(value.inner)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterBoolean.write(value.compressed, buf)
        _UniffiFfiConverterBytes.write(value.inner, buf)

@dataclass
class FidelityBond:
    def __init__(self, *, amount:Amount, lock_time:LockTime, pubkey:PublicKey):
        self.amount = amount
        self.lock_time = lock_time
        self.pubkey = pubkey
        
        

    
    def __str__(self):
        return "FidelityBond(amount={}, lock_time={}, pubkey={})".format(self.amount, self.lock_time, self.pubkey)
    def __eq__(self, other):
        if self.amount != other.amount:
            return False
        if self.lock_time != other.lock_time:
            return False
        if self.pubkey != other.pubkey:
            return False
        return True

class _UniffiFfiConverterTypeFidelityBond(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FidelityBond(
            amount=_UniffiFfiConverterTypeAmount.read(buf),
            lock_time=_UniffiFfiConverterTypeLockTime.read(buf),
            pubkey=_UniffiFfiConverterTypePublicKey.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterTypeAmount.check_lower(value.amount)
        _UniffiFfiConverterTypeLockTime.check_lower(value.lock_time)
        _UniffiFfiConverterTypePublicKey.check_lower(value.pubkey)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterTypeAmount.write(value.amount, buf)
        _UniffiFfiConverterTypeLockTime.write(value.lock_time, buf)
        _UniffiFfiConverterTypePublicKey.write(value.pubkey, buf)

@dataclass
class FidelityProof:
    def __init__(self, *, bond:FidelityBond, cert_hash:bytes, cert_sig:bytes):
        self.bond = bond
        self.cert_hash = cert_hash
        self.cert_sig = cert_sig
        
        

    
    def __str__(self):
        return "FidelityProof(bond={}, cert_hash={}, cert_sig={})".format(self.bond, self.cert_hash, self.cert_sig)
    def __eq__(self, other):
        if self.bond != other.bond:
            return False
        if self.cert_hash != other.cert_hash:
            return False
        if self.cert_sig != other.cert_sig:
            return False
        return True

class _UniffiFfiConverterTypeFidelityProof(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FidelityProof(
            bond=_UniffiFfiConverterTypeFidelityBond.read(buf),
            cert_hash=_UniffiFfiConverterBytes.read(buf),
            cert_sig=_UniffiFfiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterTypeFidelityBond.check_lower(value.bond)
        _UniffiFfiConverterBytes.check_lower(value.cert_hash)
        _UniffiFfiConverterBytes.check_lower(value.cert_sig)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterTypeFidelityBond.write(value.bond, buf)
        _UniffiFfiConverterBytes.write(value.cert_hash, buf)
        _UniffiFfiConverterBytes.write(value.cert_sig, buf)

class _UniffiFfiConverterOptionalTypeAddress(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeAddress.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeAddress.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeAddress.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

@dataclass
class SignedAmountSats:
    def __init__(self, *, sats:int):
        self.sats = sats
        
        

    
    def __str__(self):
        return "SignedAmountSats(sats={})".format(self.sats)
    def __eq__(self, other):
        if self.sats != other.sats:
            return False
        return True

class _UniffiFfiConverterTypeSignedAmountSats(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SignedAmountSats(
            sats=_UniffiFfiConverterInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterInt64.check_lower(value.sats)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterInt64.write(value.sats, buf)

class _UniffiFfiConverterOptionalString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterOptionalTypeSignedAmountSats(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeSignedAmountSats.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeSignedAmountSats.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeSignedAmountSats.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterOptionalBoolean(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterBoolean.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterBoolean.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterBoolean.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

@dataclass
class GetTransactionResultDetail:
    def __init__(self, *, address:typing.Optional[Address], category:str, amount:SignedAmountSats, label:typing.Optional[str], vout:int, fee:typing.Optional[SignedAmountSats], abandoned:typing.Optional[bool]):
        self.address = address
        self.category = category
        self.amount = amount
        self.label = label
        self.vout = vout
        self.fee = fee
        self.abandoned = abandoned
        
        

    
    def __str__(self):
        return "GetTransactionResultDetail(address={}, category={}, amount={}, label={}, vout={}, fee={}, abandoned={})".format(self.address, self.category, self.amount, self.label, self.vout, self.fee, self.abandoned)
    def __eq__(self, other):
        if self.address != other.address:
            return False
        if self.category != other.category:
            return False
        if self.amount != other.amount:
            return False
        if self.label != other.label:
            return False
        if self.vout != other.vout:
            return False
        if self.fee != other.fee:
            return False
        if self.abandoned != other.abandoned:
            return False
        return True

class _UniffiFfiConverterTypeGetTransactionResultDetail(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GetTransactionResultDetail(
            address=_UniffiFfiConverterOptionalTypeAddress.read(buf),
            category=_UniffiFfiConverterString.read(buf),
            amount=_UniffiFfiConverterTypeSignedAmountSats.read(buf),
            label=_UniffiFfiConverterOptionalString.read(buf),
            vout=_UniffiFfiConverterUInt32.read(buf),
            fee=_UniffiFfiConverterOptionalTypeSignedAmountSats.read(buf),
            abandoned=_UniffiFfiConverterOptionalBoolean.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterOptionalTypeAddress.check_lower(value.address)
        _UniffiFfiConverterString.check_lower(value.category)
        _UniffiFfiConverterTypeSignedAmountSats.check_lower(value.amount)
        _UniffiFfiConverterOptionalString.check_lower(value.label)
        _UniffiFfiConverterUInt32.check_lower(value.vout)
        _UniffiFfiConverterOptionalTypeSignedAmountSats.check_lower(value.fee)
        _UniffiFfiConverterOptionalBoolean.check_lower(value.abandoned)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterOptionalTypeAddress.write(value.address, buf)
        _UniffiFfiConverterString.write(value.category, buf)
        _UniffiFfiConverterTypeSignedAmountSats.write(value.amount, buf)
        _UniffiFfiConverterOptionalString.write(value.label, buf)
        _UniffiFfiConverterUInt32.write(value.vout, buf)
        _UniffiFfiConverterOptionalTypeSignedAmountSats.write(value.fee, buf)
        _UniffiFfiConverterOptionalBoolean.write(value.abandoned, buf)

class _UniffiFfiConverterInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i32"
    VALUE_MIN = -2**31
    VALUE_MAX = 2**31

    @staticmethod
    def read(buf):
        return buf.read_i32()

    @staticmethod
    def write(value, buf):
        buf.write_i32(value)

class _UniffiFfiConverterOptionalUInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterUInt32.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterUInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterUInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterOptionalInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterInt64.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

@dataclass
class Txid:
    def __init__(self, *, value:str):
        self.value = value
        
        

    
    def __str__(self):
        return "Txid(value={})".format(self.value)
    def __eq__(self, other):
        if self.value != other.value:
            return False
        return True

class _UniffiFfiConverterTypeTxid(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Txid(
            value=_UniffiFfiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.value)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.value, buf)

class _UniffiFfiConverterSequenceTypeTxid(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeTxid.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeTxid.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeTxid.read(buf) for i in range(count)
        ]

@dataclass
class WalletTxInfo:
    def __init__(self, *, confirmations:int, blockhash:typing.Optional[str], blockindex:typing.Optional[int], blocktime:typing.Optional[int], blockheight:typing.Optional[int], txid:Txid, time:int, timereceived:int, bip125_replaceable:str, wallet_conflicts:typing.List[Txid]):
        self.confirmations = confirmations
        self.blockhash = blockhash
        self.blockindex = blockindex
        self.blocktime = blocktime
        self.blockheight = blockheight
        self.txid = txid
        self.time = time
        self.timereceived = timereceived
        self.bip125_replaceable = bip125_replaceable
        self.wallet_conflicts = wallet_conflicts
        
        

    
    def __str__(self):
        return "WalletTxInfo(confirmations={}, blockhash={}, blockindex={}, blocktime={}, blockheight={}, txid={}, time={}, timereceived={}, bip125_replaceable={}, wallet_conflicts={})".format(self.confirmations, self.blockhash, self.blockindex, self.blocktime, self.blockheight, self.txid, self.time, self.timereceived, self.bip125_replaceable, self.wallet_conflicts)
    def __eq__(self, other):
        if self.confirmations != other.confirmations:
            return False
        if self.blockhash != other.blockhash:
            return False
        if self.blockindex != other.blockindex:
            return False
        if self.blocktime != other.blocktime:
            return False
        if self.blockheight != other.blockheight:
            return False
        if self.txid != other.txid:
            return False
        if self.time != other.time:
            return False
        if self.timereceived != other.timereceived:
            return False
        if self.bip125_replaceable != other.bip125_replaceable:
            return False
        if self.wallet_conflicts != other.wallet_conflicts:
            return False
        return True

class _UniffiFfiConverterTypeWalletTxInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return WalletTxInfo(
            confirmations=_UniffiFfiConverterInt32.read(buf),
            blockhash=_UniffiFfiConverterOptionalString.read(buf),
            blockindex=_UniffiFfiConverterOptionalUInt32.read(buf),
            blocktime=_UniffiFfiConverterOptionalInt64.read(buf),
            blockheight=_UniffiFfiConverterOptionalUInt32.read(buf),
            txid=_UniffiFfiConverterTypeTxid.read(buf),
            time=_UniffiFfiConverterInt64.read(buf),
            timereceived=_UniffiFfiConverterInt64.read(buf),
            bip125_replaceable=_UniffiFfiConverterString.read(buf),
            wallet_conflicts=_UniffiFfiConverterSequenceTypeTxid.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterInt32.check_lower(value.confirmations)
        _UniffiFfiConverterOptionalString.check_lower(value.blockhash)
        _UniffiFfiConverterOptionalUInt32.check_lower(value.blockindex)
        _UniffiFfiConverterOptionalInt64.check_lower(value.blocktime)
        _UniffiFfiConverterOptionalUInt32.check_lower(value.blockheight)
        _UniffiFfiConverterTypeTxid.check_lower(value.txid)
        _UniffiFfiConverterInt64.check_lower(value.time)
        _UniffiFfiConverterInt64.check_lower(value.timereceived)
        _UniffiFfiConverterString.check_lower(value.bip125_replaceable)
        _UniffiFfiConverterSequenceTypeTxid.check_lower(value.wallet_conflicts)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterInt32.write(value.confirmations, buf)
        _UniffiFfiConverterOptionalString.write(value.blockhash, buf)
        _UniffiFfiConverterOptionalUInt32.write(value.blockindex, buf)
        _UniffiFfiConverterOptionalInt64.write(value.blocktime, buf)
        _UniffiFfiConverterOptionalUInt32.write(value.blockheight, buf)
        _UniffiFfiConverterTypeTxid.write(value.txid, buf)
        _UniffiFfiConverterInt64.write(value.time, buf)
        _UniffiFfiConverterInt64.write(value.timereceived, buf)
        _UniffiFfiConverterString.write(value.bip125_replaceable, buf)
        _UniffiFfiConverterSequenceTypeTxid.write(value.wallet_conflicts, buf)

@dataclass
class ListTransactionResult:
    def __init__(self, *, info:WalletTxInfo, detail:GetTransactionResultDetail, trusted:typing.Optional[bool], comment:typing.Optional[str]):
        self.info = info
        self.detail = detail
        self.trusted = trusted
        self.comment = comment
        
        

    
    def __str__(self):
        return "ListTransactionResult(info={}, detail={}, trusted={}, comment={})".format(self.info, self.detail, self.trusted, self.comment)
    def __eq__(self, other):
        if self.info != other.info:
            return False
        if self.detail != other.detail:
            return False
        if self.trusted != other.trusted:
            return False
        if self.comment != other.comment:
            return False
        return True

class _UniffiFfiConverterTypeListTransactionResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ListTransactionResult(
            info=_UniffiFfiConverterTypeWalletTxInfo.read(buf),
            detail=_UniffiFfiConverterTypeGetTransactionResultDetail.read(buf),
            trusted=_UniffiFfiConverterOptionalBoolean.read(buf),
            comment=_UniffiFfiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterTypeWalletTxInfo.check_lower(value.info)
        _UniffiFfiConverterTypeGetTransactionResultDetail.check_lower(value.detail)
        _UniffiFfiConverterOptionalBoolean.check_lower(value.trusted)
        _UniffiFfiConverterOptionalString.check_lower(value.comment)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterTypeWalletTxInfo.write(value.info, buf)
        _UniffiFfiConverterTypeGetTransactionResultDetail.write(value.detail, buf)
        _UniffiFfiConverterOptionalBoolean.write(value.trusted, buf)
        _UniffiFfiConverterOptionalString.write(value.comment, buf)

@dataclass
class ScriptBuf:
    def __init__(self, *, hex:str):
        self.hex = hex
        
        

    
    def __str__(self):
        return "ScriptBuf(hex={})".format(self.hex)
    def __eq__(self, other):
        if self.hex != other.hex:
            return False
        return True

class _UniffiFfiConverterTypeScriptBuf(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ScriptBuf(
            hex=_UniffiFfiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.hex)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.hex, buf)

class _UniffiFfiConverterOptionalTypeScriptBuf(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeScriptBuf.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeScriptBuf.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeScriptBuf.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

@dataclass
class ListUnspentResultEntry:
    def __init__(self, *, txid:Txid, vout:int, address:typing.Optional[str], label:typing.Optional[str], script_pub_key:ScriptBuf, amount:Amount, confirmations:int, redeem_script:typing.Optional[ScriptBuf], witness_script:typing.Optional[ScriptBuf], spendable:bool, solvable:bool, desc:typing.Optional[str], safe:bool):
        self.txid = txid
        self.vout = vout
        self.address = address
        self.label = label
        self.script_pub_key = script_pub_key
        self.amount = amount
        self.confirmations = confirmations
        self.redeem_script = redeem_script
        self.witness_script = witness_script
        self.spendable = spendable
        self.solvable = solvable
        self.desc = desc
        self.safe = safe
        
        

    
    def __str__(self):
        return "ListUnspentResultEntry(txid={}, vout={}, address={}, label={}, script_pub_key={}, amount={}, confirmations={}, redeem_script={}, witness_script={}, spendable={}, solvable={}, desc={}, safe={})".format(self.txid, self.vout, self.address, self.label, self.script_pub_key, self.amount, self.confirmations, self.redeem_script, self.witness_script, self.spendable, self.solvable, self.desc, self.safe)
    def __eq__(self, other):
        if self.txid != other.txid:
            return False
        if self.vout != other.vout:
            return False
        if self.address != other.address:
            return False
        if self.label != other.label:
            return False
        if self.script_pub_key != other.script_pub_key:
            return False
        if self.amount != other.amount:
            return False
        if self.confirmations != other.confirmations:
            return False
        if self.redeem_script != other.redeem_script:
            return False
        if self.witness_script != other.witness_script:
            return False
        if self.spendable != other.spendable:
            return False
        if self.solvable != other.solvable:
            return False
        if self.desc != other.desc:
            return False
        if self.safe != other.safe:
            return False
        return True

class _UniffiFfiConverterTypeListUnspentResultEntry(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ListUnspentResultEntry(
            txid=_UniffiFfiConverterTypeTxid.read(buf),
            vout=_UniffiFfiConverterUInt32.read(buf),
            address=_UniffiFfiConverterOptionalString.read(buf),
            label=_UniffiFfiConverterOptionalString.read(buf),
            script_pub_key=_UniffiFfiConverterTypeScriptBuf.read(buf),
            amount=_UniffiFfiConverterTypeAmount.read(buf),
            confirmations=_UniffiFfiConverterUInt32.read(buf),
            redeem_script=_UniffiFfiConverterOptionalTypeScriptBuf.read(buf),
            witness_script=_UniffiFfiConverterOptionalTypeScriptBuf.read(buf),
            spendable=_UniffiFfiConverterBoolean.read(buf),
            solvable=_UniffiFfiConverterBoolean.read(buf),
            desc=_UniffiFfiConverterOptionalString.read(buf),
            safe=_UniffiFfiConverterBoolean.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterTypeTxid.check_lower(value.txid)
        _UniffiFfiConverterUInt32.check_lower(value.vout)
        _UniffiFfiConverterOptionalString.check_lower(value.address)
        _UniffiFfiConverterOptionalString.check_lower(value.label)
        _UniffiFfiConverterTypeScriptBuf.check_lower(value.script_pub_key)
        _UniffiFfiConverterTypeAmount.check_lower(value.amount)
        _UniffiFfiConverterUInt32.check_lower(value.confirmations)
        _UniffiFfiConverterOptionalTypeScriptBuf.check_lower(value.redeem_script)
        _UniffiFfiConverterOptionalTypeScriptBuf.check_lower(value.witness_script)
        _UniffiFfiConverterBoolean.check_lower(value.spendable)
        _UniffiFfiConverterBoolean.check_lower(value.solvable)
        _UniffiFfiConverterOptionalString.check_lower(value.desc)
        _UniffiFfiConverterBoolean.check_lower(value.safe)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterTypeTxid.write(value.txid, buf)
        _UniffiFfiConverterUInt32.write(value.vout, buf)
        _UniffiFfiConverterOptionalString.write(value.address, buf)
        _UniffiFfiConverterOptionalString.write(value.label, buf)
        _UniffiFfiConverterTypeScriptBuf.write(value.script_pub_key, buf)
        _UniffiFfiConverterTypeAmount.write(value.amount, buf)
        _UniffiFfiConverterUInt32.write(value.confirmations, buf)
        _UniffiFfiConverterOptionalTypeScriptBuf.write(value.redeem_script, buf)
        _UniffiFfiConverterOptionalTypeScriptBuf.write(value.witness_script, buf)
        _UniffiFfiConverterBoolean.write(value.spendable, buf)
        _UniffiFfiConverterBoolean.write(value.solvable, buf)
        _UniffiFfiConverterOptionalString.write(value.desc, buf)
        _UniffiFfiConverterBoolean.write(value.safe, buf)

@dataclass
class MakerAddress:
    def __init__(self, *, address:str):
        self.address = address
        
        

    
    def __str__(self):
        return "MakerAddress(address={})".format(self.address)
    def __eq__(self, other):
        if self.address != other.address:
            return False
        return True

class _UniffiFfiConverterTypeMakerAddress(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MakerAddress(
            address=_UniffiFfiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.address)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.address, buf)

@dataclass
class MakerFeeInfo:
    def __init__(self, *, maker_index:int, maker_address:str, base_fee:float, amount_relative_fee:float, time_relative_fee:float, total_fee:float):
        self.maker_index = maker_index
        self.maker_address = maker_address
        self.base_fee = base_fee
        self.amount_relative_fee = amount_relative_fee
        self.time_relative_fee = time_relative_fee
        self.total_fee = total_fee
        
        

    
    def __str__(self):
        return "MakerFeeInfo(maker_index={}, maker_address={}, base_fee={}, amount_relative_fee={}, time_relative_fee={}, total_fee={})".format(self.maker_index, self.maker_address, self.base_fee, self.amount_relative_fee, self.time_relative_fee, self.total_fee)
    def __eq__(self, other):
        if self.maker_index != other.maker_index:
            return False
        if self.maker_address != other.maker_address:
            return False
        if self.base_fee != other.base_fee:
            return False
        if self.amount_relative_fee != other.amount_relative_fee:
            return False
        if self.time_relative_fee != other.time_relative_fee:
            return False
        if self.total_fee != other.total_fee:
            return False
        return True

class _UniffiFfiConverterTypeMakerFeeInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MakerFeeInfo(
            maker_index=_UniffiFfiConverterUInt32.read(buf),
            maker_address=_UniffiFfiConverterString.read(buf),
            base_fee=_UniffiFfiConverterFloat64.read(buf),
            amount_relative_fee=_UniffiFfiConverterFloat64.read(buf),
            time_relative_fee=_UniffiFfiConverterFloat64.read(buf),
            total_fee=_UniffiFfiConverterFloat64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterUInt32.check_lower(value.maker_index)
        _UniffiFfiConverterString.check_lower(value.maker_address)
        _UniffiFfiConverterFloat64.check_lower(value.base_fee)
        _UniffiFfiConverterFloat64.check_lower(value.amount_relative_fee)
        _UniffiFfiConverterFloat64.check_lower(value.time_relative_fee)
        _UniffiFfiConverterFloat64.check_lower(value.total_fee)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterUInt32.write(value.maker_index, buf)
        _UniffiFfiConverterString.write(value.maker_address, buf)
        _UniffiFfiConverterFloat64.write(value.base_fee, buf)
        _UniffiFfiConverterFloat64.write(value.amount_relative_fee, buf)
        _UniffiFfiConverterFloat64.write(value.time_relative_fee, buf)
        _UniffiFfiConverterFloat64.write(value.total_fee, buf)

class _UniffiFfiConverterUInt16(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u16"
    VALUE_MIN = 0
    VALUE_MAX = 2**16

    @staticmethod
    def read(buf):
        return buf.read_u16()

    @staticmethod
    def write(value, buf):
        buf.write_u16(value)

@dataclass
class Offer:
    def __init__(self, *, base_fee:int, amount_relative_fee_pct:float, time_relative_fee_pct:float, required_confirms:int, minimum_locktime:int, max_size:int, min_size:int, tweakable_point:PublicKey, fidelity:FidelityProof):
        self.base_fee = base_fee
        self.amount_relative_fee_pct = amount_relative_fee_pct
        self.time_relative_fee_pct = time_relative_fee_pct
        self.required_confirms = required_confirms
        self.minimum_locktime = minimum_locktime
        self.max_size = max_size
        self.min_size = min_size
        self.tweakable_point = tweakable_point
        self.fidelity = fidelity
        
        

    
    def __str__(self):
        return "Offer(base_fee={}, amount_relative_fee_pct={}, time_relative_fee_pct={}, required_confirms={}, minimum_locktime={}, max_size={}, min_size={}, tweakable_point={}, fidelity={})".format(self.base_fee, self.amount_relative_fee_pct, self.time_relative_fee_pct, self.required_confirms, self.minimum_locktime, self.max_size, self.min_size, self.tweakable_point, self.fidelity)
    def __eq__(self, other):
        if self.base_fee != other.base_fee:
            return False
        if self.amount_relative_fee_pct != other.amount_relative_fee_pct:
            return False
        if self.time_relative_fee_pct != other.time_relative_fee_pct:
            return False
        if self.required_confirms != other.required_confirms:
            return False
        if self.minimum_locktime != other.minimum_locktime:
            return False
        if self.max_size != other.max_size:
            return False
        if self.min_size != other.min_size:
            return False
        if self.tweakable_point != other.tweakable_point:
            return False
        if self.fidelity != other.fidelity:
            return False
        return True

class _UniffiFfiConverterTypeOffer(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Offer(
            base_fee=_UniffiFfiConverterInt64.read(buf),
            amount_relative_fee_pct=_UniffiFfiConverterFloat64.read(buf),
            time_relative_fee_pct=_UniffiFfiConverterFloat64.read(buf),
            required_confirms=_UniffiFfiConverterUInt32.read(buf),
            minimum_locktime=_UniffiFfiConverterUInt16.read(buf),
            max_size=_UniffiFfiConverterInt64.read(buf),
            min_size=_UniffiFfiConverterInt64.read(buf),
            tweakable_point=_UniffiFfiConverterTypePublicKey.read(buf),
            fidelity=_UniffiFfiConverterTypeFidelityProof.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterInt64.check_lower(value.base_fee)
        _UniffiFfiConverterFloat64.check_lower(value.amount_relative_fee_pct)
        _UniffiFfiConverterFloat64.check_lower(value.time_relative_fee_pct)
        _UniffiFfiConverterUInt32.check_lower(value.required_confirms)
        _UniffiFfiConverterUInt16.check_lower(value.minimum_locktime)
        _UniffiFfiConverterInt64.check_lower(value.max_size)
        _UniffiFfiConverterInt64.check_lower(value.min_size)
        _UniffiFfiConverterTypePublicKey.check_lower(value.tweakable_point)
        _UniffiFfiConverterTypeFidelityProof.check_lower(value.fidelity)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterInt64.write(value.base_fee, buf)
        _UniffiFfiConverterFloat64.write(value.amount_relative_fee_pct, buf)
        _UniffiFfiConverterFloat64.write(value.time_relative_fee_pct, buf)
        _UniffiFfiConverterUInt32.write(value.required_confirms, buf)
        _UniffiFfiConverterUInt16.write(value.minimum_locktime, buf)
        _UniffiFfiConverterInt64.write(value.max_size, buf)
        _UniffiFfiConverterInt64.write(value.min_size, buf)
        _UniffiFfiConverterTypePublicKey.write(value.tweakable_point, buf)
        _UniffiFfiConverterTypeFidelityProof.write(value.fidelity, buf)

class _UniffiFfiConverterOptionalTypeOffer(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeOffer.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeOffer.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeOffer.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterUInt8(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u8"
    VALUE_MIN = 0
    VALUE_MAX = 2**8

    @staticmethod
    def read(buf):
        return buf.read_u8()

    @staticmethod
    def write(value, buf):
        buf.write_u8(value)

class _UniffiFfiConverterOptionalUInt8(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterUInt8.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterUInt8.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterUInt8.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

@dataclass
class MakerState:
    def __init__(self, *, state_type:str, retries:typing.Optional[int]):
        self.state_type = state_type
        self.retries = retries
        
        

    
    def __str__(self):
        return "MakerState(state_type={}, retries={})".format(self.state_type, self.retries)
    def __eq__(self, other):
        if self.state_type != other.state_type:
            return False
        if self.retries != other.retries:
            return False
        return True

class _UniffiFfiConverterTypeMakerState(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MakerState(
            state_type=_UniffiFfiConverterString.read(buf),
            retries=_UniffiFfiConverterOptionalUInt8.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.state_type)
        _UniffiFfiConverterOptionalUInt8.check_lower(value.retries)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.state_type, buf)
        _UniffiFfiConverterOptionalUInt8.write(value.retries, buf)

@dataclass
class MakerProtocol:
    def __init__(self, *, protocol_type:str):
        self.protocol_type = protocol_type
        
        

    
    def __str__(self):
        return "MakerProtocol(protocol_type={})".format(self.protocol_type)
    def __eq__(self, other):
        if self.protocol_type != other.protocol_type:
            return False
        return True

class _UniffiFfiConverterTypeMakerProtocol(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MakerProtocol(
            protocol_type=_UniffiFfiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.protocol_type)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.protocol_type, buf)

class _UniffiFfiConverterOptionalTypeMakerProtocol(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeMakerProtocol.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeMakerProtocol.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeMakerProtocol.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

@dataclass
class MakerOfferCandidate:
    def __init__(self, *, address:MakerAddress, offer:typing.Optional[Offer], state:MakerState, protocol:typing.Optional[MakerProtocol]):
        self.address = address
        self.offer = offer
        self.state = state
        self.protocol = protocol
        
        

    
    def __str__(self):
        return "MakerOfferCandidate(address={}, offer={}, state={}, protocol={})".format(self.address, self.offer, self.state, self.protocol)
    def __eq__(self, other):
        if self.address != other.address:
            return False
        if self.offer != other.offer:
            return False
        if self.state != other.state:
            return False
        if self.protocol != other.protocol:
            return False
        return True

class _UniffiFfiConverterTypeMakerOfferCandidate(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MakerOfferCandidate(
            address=_UniffiFfiConverterTypeMakerAddress.read(buf),
            offer=_UniffiFfiConverterOptionalTypeOffer.read(buf),
            state=_UniffiFfiConverterTypeMakerState.read(buf),
            protocol=_UniffiFfiConverterOptionalTypeMakerProtocol.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterTypeMakerAddress.check_lower(value.address)
        _UniffiFfiConverterOptionalTypeOffer.check_lower(value.offer)
        _UniffiFfiConverterTypeMakerState.check_lower(value.state)
        _UniffiFfiConverterOptionalTypeMakerProtocol.check_lower(value.protocol)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterTypeMakerAddress.write(value.address, buf)
        _UniffiFfiConverterOptionalTypeOffer.write(value.offer, buf)
        _UniffiFfiConverterTypeMakerState.write(value.state, buf)
        _UniffiFfiConverterOptionalTypeMakerProtocol.write(value.protocol, buf)

class _UniffiFfiConverterSequenceTypeMakerOfferCandidate(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeMakerOfferCandidate.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeMakerOfferCandidate.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeMakerOfferCandidate.read(buf) for i in range(count)
        ]

@dataclass
class OfferBook:
    def __init__(self, *, makers:typing.List[MakerOfferCandidate]):
        self.makers = makers
        
        

    
    def __str__(self):
        return "OfferBook(makers={})".format(self.makers)
    def __eq__(self, other):
        if self.makers != other.makers:
            return False
        return True

class _UniffiFfiConverterTypeOfferBook(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OfferBook(
            makers=_UniffiFfiConverterSequenceTypeMakerOfferCandidate.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterSequenceTypeMakerOfferCandidate.check_lower(value.makers)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterSequenceTypeMakerOfferCandidate.write(value.makers, buf)

@dataclass
class OutPoint:
    def __init__(self, *, txid:Txid, vout:int):
        self.txid = txid
        self.vout = vout
        
        

    
    def __str__(self):
        return "OutPoint(txid={}, vout={})".format(self.txid, self.vout)
    def __eq__(self, other):
        if self.txid != other.txid:
            return False
        if self.vout != other.vout:
            return False
        return True

class _UniffiFfiConverterTypeOutPoint(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OutPoint(
            txid=_UniffiFfiConverterTypeTxid.read(buf),
            vout=_UniffiFfiConverterUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterTypeTxid.check_lower(value.txid)
        _UniffiFfiConverterUInt32.check_lower(value.vout)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterTypeTxid.write(value.txid, buf)
        _UniffiFfiConverterUInt32.write(value.vout, buf)

@dataclass
class RpcConfig:
    def __init__(self, *, url:str, username:str, password:str, wallet_name:str):
        self.url = url
        self.username = username
        self.password = password
        self.wallet_name = wallet_name
        
        

    
    def __str__(self):
        return "RpcConfig(url={}, username={}, password={}, wallet_name={})".format(self.url, self.username, self.password, self.wallet_name)
    def __eq__(self, other):
        if self.url != other.url:
            return False
        if self.username != other.username:
            return False
        if self.password != other.password:
            return False
        if self.wallet_name != other.wallet_name:
            return False
        return True

class _UniffiFfiConverterTypeRPCConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RpcConfig(
            url=_UniffiFfiConverterString.read(buf),
            username=_UniffiFfiConverterString.read(buf),
            password=_UniffiFfiConverterString.read(buf),
            wallet_name=_UniffiFfiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.url)
        _UniffiFfiConverterString.check_lower(value.username)
        _UniffiFfiConverterString.check_lower(value.password)
        _UniffiFfiConverterString.check_lower(value.wallet_name)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.url, buf)
        _UniffiFfiConverterString.write(value.username, buf)
        _UniffiFfiConverterString.write(value.password, buf)
        _UniffiFfiConverterString.write(value.wallet_name, buf)

class _UniffiFfiConverterUInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u64"
    VALUE_MIN = 0
    VALUE_MAX = 2**64

    @staticmethod
    def read(buf):
        return buf.read_u64()

    @staticmethod
    def write(value, buf):
        buf.write_u64(value)

class _UniffiFfiConverterSequenceTypeOutPoint(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeOutPoint.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeOutPoint.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeOutPoint.read(buf) for i in range(count)
        ]

class _UniffiFfiConverterOptionalSequenceTypeOutPoint(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterSequenceTypeOutPoint.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterSequenceTypeOutPoint.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterSequenceTypeOutPoint.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

@dataclass
class SwapParams:
    def __init__(self, *, send_amount:int, maker_count:int, manually_selected_outpoints:typing.Optional[typing.List[OutPoint]]):
        self.send_amount = send_amount
        self.maker_count = maker_count
        self.manually_selected_outpoints = manually_selected_outpoints
        
        

    
    def __str__(self):
        return "SwapParams(send_amount={}, maker_count={}, manually_selected_outpoints={})".format(self.send_amount, self.maker_count, self.manually_selected_outpoints)
    def __eq__(self, other):
        if self.send_amount != other.send_amount:
            return False
        if self.maker_count != other.maker_count:
            return False
        if self.manually_selected_outpoints != other.manually_selected_outpoints:
            return False
        return True

class _UniffiFfiConverterTypeSwapParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SwapParams(
            send_amount=_UniffiFfiConverterUInt64.read(buf),
            maker_count=_UniffiFfiConverterUInt32.read(buf),
            manually_selected_outpoints=_UniffiFfiConverterOptionalSequenceTypeOutPoint.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterUInt64.check_lower(value.send_amount)
        _UniffiFfiConverterUInt32.check_lower(value.maker_count)
        _UniffiFfiConverterOptionalSequenceTypeOutPoint.check_lower(value.manually_selected_outpoints)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterUInt64.write(value.send_amount, buf)
        _UniffiFfiConverterUInt32.write(value.maker_count, buf)
        _UniffiFfiConverterOptionalSequenceTypeOutPoint.write(value.manually_selected_outpoints, buf)

class _UniffiFfiConverterSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterString.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterString.read(buf) for i in range(count)
        ]

class _UniffiFfiConverterSequenceSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterSequenceString.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterSequenceString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterSequenceString.read(buf) for i in range(count)
        ]

class _UniffiFfiConverterSequenceTypeMakerFeeInfo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeMakerFeeInfo.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeMakerFeeInfo.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeMakerFeeInfo.read(buf) for i in range(count)
        ]

class _UniffiFfiConverterSequenceInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterInt64.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterInt64.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterInt64.read(buf) for i in range(count)
        ]

@dataclass
class UtxoWithAddress:
    def __init__(self, *, amount:int, address:str):
        self.amount = amount
        self.address = address
        
        

    
    def __str__(self):
        return "UtxoWithAddress(amount={}, address={})".format(self.amount, self.address)
    def __eq__(self, other):
        if self.amount != other.amount:
            return False
        if self.address != other.address:
            return False
        return True

class _UniffiFfiConverterTypeUtxoWithAddress(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return UtxoWithAddress(
            amount=_UniffiFfiConverterInt64.read(buf),
            address=_UniffiFfiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterInt64.check_lower(value.amount)
        _UniffiFfiConverterString.check_lower(value.address)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterInt64.write(value.amount, buf)
        _UniffiFfiConverterString.write(value.address, buf)

class _UniffiFfiConverterSequenceTypeUtxoWithAddress(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeUtxoWithAddress.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeUtxoWithAddress.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeUtxoWithAddress.read(buf) for i in range(count)
        ]

@dataclass
class SwapReport:
    def __init__(self, *, swap_id:str, swap_duration_seconds:float, target_amount:int, total_input_amount:int, total_output_amount:int, makers_count:int, maker_addresses:typing.List[str], total_funding_txs:int, funding_txids_by_hop:typing.List[typing.List[str]], total_fee:int, total_maker_fees:int, mining_fee:int, fee_percentage:float, maker_fee_info:typing.List[MakerFeeInfo], input_utxos:typing.List[int], output_change_amounts:typing.List[int], output_swap_amounts:typing.List[int], output_change_utxos:typing.List[UtxoWithAddress], output_swap_utxos:typing.List[UtxoWithAddress]):
        self.swap_id = swap_id
        self.swap_duration_seconds = swap_duration_seconds
        self.target_amount = target_amount
        self.total_input_amount = total_input_amount
        self.total_output_amount = total_output_amount
        self.makers_count = makers_count
        self.maker_addresses = maker_addresses
        self.total_funding_txs = total_funding_txs
        self.funding_txids_by_hop = funding_txids_by_hop
        self.total_fee = total_fee
        self.total_maker_fees = total_maker_fees
        self.mining_fee = mining_fee
        self.fee_percentage = fee_percentage
        self.maker_fee_info = maker_fee_info
        self.input_utxos = input_utxos
        self.output_change_amounts = output_change_amounts
        self.output_swap_amounts = output_swap_amounts
        self.output_change_utxos = output_change_utxos
        self.output_swap_utxos = output_swap_utxos
        
        

    
    def __str__(self):
        return "SwapReport(swap_id={}, swap_duration_seconds={}, target_amount={}, total_input_amount={}, total_output_amount={}, makers_count={}, maker_addresses={}, total_funding_txs={}, funding_txids_by_hop={}, total_fee={}, total_maker_fees={}, mining_fee={}, fee_percentage={}, maker_fee_info={}, input_utxos={}, output_change_amounts={}, output_swap_amounts={}, output_change_utxos={}, output_swap_utxos={})".format(self.swap_id, self.swap_duration_seconds, self.target_amount, self.total_input_amount, self.total_output_amount, self.makers_count, self.maker_addresses, self.total_funding_txs, self.funding_txids_by_hop, self.total_fee, self.total_maker_fees, self.mining_fee, self.fee_percentage, self.maker_fee_info, self.input_utxos, self.output_change_amounts, self.output_swap_amounts, self.output_change_utxos, self.output_swap_utxos)
    def __eq__(self, other):
        if self.swap_id != other.swap_id:
            return False
        if self.swap_duration_seconds != other.swap_duration_seconds:
            return False
        if self.target_amount != other.target_amount:
            return False
        if self.total_input_amount != other.total_input_amount:
            return False
        if self.total_output_amount != other.total_output_amount:
            return False
        if self.makers_count != other.makers_count:
            return False
        if self.maker_addresses != other.maker_addresses:
            return False
        if self.total_funding_txs != other.total_funding_txs:
            return False
        if self.funding_txids_by_hop != other.funding_txids_by_hop:
            return False
        if self.total_fee != other.total_fee:
            return False
        if self.total_maker_fees != other.total_maker_fees:
            return False
        if self.mining_fee != other.mining_fee:
            return False
        if self.fee_percentage != other.fee_percentage:
            return False
        if self.maker_fee_info != other.maker_fee_info:
            return False
        if self.input_utxos != other.input_utxos:
            return False
        if self.output_change_amounts != other.output_change_amounts:
            return False
        if self.output_swap_amounts != other.output_swap_amounts:
            return False
        if self.output_change_utxos != other.output_change_utxos:
            return False
        if self.output_swap_utxos != other.output_swap_utxos:
            return False
        return True

class _UniffiFfiConverterTypeSwapReport(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SwapReport(
            swap_id=_UniffiFfiConverterString.read(buf),
            swap_duration_seconds=_UniffiFfiConverterFloat64.read(buf),
            target_amount=_UniffiFfiConverterInt64.read(buf),
            total_input_amount=_UniffiFfiConverterInt64.read(buf),
            total_output_amount=_UniffiFfiConverterInt64.read(buf),
            makers_count=_UniffiFfiConverterUInt32.read(buf),
            maker_addresses=_UniffiFfiConverterSequenceString.read(buf),
            total_funding_txs=_UniffiFfiConverterInt64.read(buf),
            funding_txids_by_hop=_UniffiFfiConverterSequenceSequenceString.read(buf),
            total_fee=_UniffiFfiConverterInt64.read(buf),
            total_maker_fees=_UniffiFfiConverterInt64.read(buf),
            mining_fee=_UniffiFfiConverterInt64.read(buf),
            fee_percentage=_UniffiFfiConverterFloat64.read(buf),
            maker_fee_info=_UniffiFfiConverterSequenceTypeMakerFeeInfo.read(buf),
            input_utxos=_UniffiFfiConverterSequenceInt64.read(buf),
            output_change_amounts=_UniffiFfiConverterSequenceInt64.read(buf),
            output_swap_amounts=_UniffiFfiConverterSequenceInt64.read(buf),
            output_change_utxos=_UniffiFfiConverterSequenceTypeUtxoWithAddress.read(buf),
            output_swap_utxos=_UniffiFfiConverterSequenceTypeUtxoWithAddress.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.swap_id)
        _UniffiFfiConverterFloat64.check_lower(value.swap_duration_seconds)
        _UniffiFfiConverterInt64.check_lower(value.target_amount)
        _UniffiFfiConverterInt64.check_lower(value.total_input_amount)
        _UniffiFfiConverterInt64.check_lower(value.total_output_amount)
        _UniffiFfiConverterUInt32.check_lower(value.makers_count)
        _UniffiFfiConverterSequenceString.check_lower(value.maker_addresses)
        _UniffiFfiConverterInt64.check_lower(value.total_funding_txs)
        _UniffiFfiConverterSequenceSequenceString.check_lower(value.funding_txids_by_hop)
        _UniffiFfiConverterInt64.check_lower(value.total_fee)
        _UniffiFfiConverterInt64.check_lower(value.total_maker_fees)
        _UniffiFfiConverterInt64.check_lower(value.mining_fee)
        _UniffiFfiConverterFloat64.check_lower(value.fee_percentage)
        _UniffiFfiConverterSequenceTypeMakerFeeInfo.check_lower(value.maker_fee_info)
        _UniffiFfiConverterSequenceInt64.check_lower(value.input_utxos)
        _UniffiFfiConverterSequenceInt64.check_lower(value.output_change_amounts)
        _UniffiFfiConverterSequenceInt64.check_lower(value.output_swap_amounts)
        _UniffiFfiConverterSequenceTypeUtxoWithAddress.check_lower(value.output_change_utxos)
        _UniffiFfiConverterSequenceTypeUtxoWithAddress.check_lower(value.output_swap_utxos)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.swap_id, buf)
        _UniffiFfiConverterFloat64.write(value.swap_duration_seconds, buf)
        _UniffiFfiConverterInt64.write(value.target_amount, buf)
        _UniffiFfiConverterInt64.write(value.total_input_amount, buf)
        _UniffiFfiConverterInt64.write(value.total_output_amount, buf)
        _UniffiFfiConverterUInt32.write(value.makers_count, buf)
        _UniffiFfiConverterSequenceString.write(value.maker_addresses, buf)
        _UniffiFfiConverterInt64.write(value.total_funding_txs, buf)
        _UniffiFfiConverterSequenceSequenceString.write(value.funding_txids_by_hop, buf)
        _UniffiFfiConverterInt64.write(value.total_fee, buf)
        _UniffiFfiConverterInt64.write(value.total_maker_fees, buf)
        _UniffiFfiConverterInt64.write(value.mining_fee, buf)
        _UniffiFfiConverterFloat64.write(value.fee_percentage, buf)
        _UniffiFfiConverterSequenceTypeMakerFeeInfo.write(value.maker_fee_info, buf)
        _UniffiFfiConverterSequenceInt64.write(value.input_utxos, buf)
        _UniffiFfiConverterSequenceInt64.write(value.output_change_amounts, buf)
        _UniffiFfiConverterSequenceInt64.write(value.output_swap_amounts, buf)
        _UniffiFfiConverterSequenceTypeUtxoWithAddress.write(value.output_change_utxos, buf)
        _UniffiFfiConverterSequenceTypeUtxoWithAddress.write(value.output_swap_utxos, buf)

@dataclass
class TaprootSwapParams:
    """
    Swap parameters for Taproot (V2) protocol
    Note: V2 has additional parameters compared to V1
"""
    def __init__(self, *, send_amount:int, maker_count:int, tx_count:typing.Optional[int], required_confirms:typing.Optional[int], manually_selected_outpoints:typing.Optional[typing.List[OutPoint]]):
        self.send_amount = send_amount
        self.maker_count = maker_count
        self.tx_count = tx_count
        self.required_confirms = required_confirms
        self.manually_selected_outpoints = manually_selected_outpoints
        
        

    
    def __str__(self):
        return "TaprootSwapParams(send_amount={}, maker_count={}, tx_count={}, required_confirms={}, manually_selected_outpoints={})".format(self.send_amount, self.maker_count, self.tx_count, self.required_confirms, self.manually_selected_outpoints)
    def __eq__(self, other):
        if self.send_amount != other.send_amount:
            return False
        if self.maker_count != other.maker_count:
            return False
        if self.tx_count != other.tx_count:
            return False
        if self.required_confirms != other.required_confirms:
            return False
        if self.manually_selected_outpoints != other.manually_selected_outpoints:
            return False
        return True

class _UniffiFfiConverterTypeTaprootSwapParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TaprootSwapParams(
            send_amount=_UniffiFfiConverterUInt64.read(buf),
            maker_count=_UniffiFfiConverterUInt32.read(buf),
            tx_count=_UniffiFfiConverterOptionalUInt32.read(buf),
            required_confirms=_UniffiFfiConverterOptionalUInt32.read(buf),
            manually_selected_outpoints=_UniffiFfiConverterOptionalSequenceTypeOutPoint.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterUInt64.check_lower(value.send_amount)
        _UniffiFfiConverterUInt32.check_lower(value.maker_count)
        _UniffiFfiConverterOptionalUInt32.check_lower(value.tx_count)
        _UniffiFfiConverterOptionalUInt32.check_lower(value.required_confirms)
        _UniffiFfiConverterOptionalSequenceTypeOutPoint.check_lower(value.manually_selected_outpoints)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterUInt64.write(value.send_amount, buf)
        _UniffiFfiConverterUInt32.write(value.maker_count, buf)
        _UniffiFfiConverterOptionalUInt32.write(value.tx_count, buf)
        _UniffiFfiConverterOptionalUInt32.write(value.required_confirms, buf)
        _UniffiFfiConverterOptionalSequenceTypeOutPoint.write(value.manually_selected_outpoints, buf)

class _UniffiFfiConverterOptionalTypeAmount(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeAmount.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeAmount.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeAmount.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

@dataclass
class UtxoSpendInfo:
    def __init__(self, *, spend_type:str, path:typing.Optional[str], multisig_redeemscript:typing.Optional[ScriptBuf], input_value:typing.Optional[Amount], index:typing.Optional[int]):
        self.spend_type = spend_type
        self.path = path
        self.multisig_redeemscript = multisig_redeemscript
        self.input_value = input_value
        self.index = index
        
        

    
    def __str__(self):
        return "UtxoSpendInfo(spend_type={}, path={}, multisig_redeemscript={}, input_value={}, index={})".format(self.spend_type, self.path, self.multisig_redeemscript, self.input_value, self.index)
    def __eq__(self, other):
        if self.spend_type != other.spend_type:
            return False
        if self.path != other.path:
            return False
        if self.multisig_redeemscript != other.multisig_redeemscript:
            return False
        if self.input_value != other.input_value:
            return False
        if self.index != other.index:
            return False
        return True

class _UniffiFfiConverterTypeUtxoSpendInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return UtxoSpendInfo(
            spend_type=_UniffiFfiConverterString.read(buf),
            path=_UniffiFfiConverterOptionalString.read(buf),
            multisig_redeemscript=_UniffiFfiConverterOptionalTypeScriptBuf.read(buf),
            input_value=_UniffiFfiConverterOptionalTypeAmount.read(buf),
            index=_UniffiFfiConverterOptionalUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.spend_type)
        _UniffiFfiConverterOptionalString.check_lower(value.path)
        _UniffiFfiConverterOptionalTypeScriptBuf.check_lower(value.multisig_redeemscript)
        _UniffiFfiConverterOptionalTypeAmount.check_lower(value.input_value)
        _UniffiFfiConverterOptionalUInt32.check_lower(value.index)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.spend_type, buf)
        _UniffiFfiConverterOptionalString.write(value.path, buf)
        _UniffiFfiConverterOptionalTypeScriptBuf.write(value.multisig_redeemscript, buf)
        _UniffiFfiConverterOptionalTypeAmount.write(value.input_value, buf)
        _UniffiFfiConverterOptionalUInt32.write(value.index, buf)

@dataclass
class TotalUtxoInfo:
    def __init__(self, *, list_unspent_result_entry:ListUnspentResultEntry, utxo_spend_info:UtxoSpendInfo):
        self.list_unspent_result_entry = list_unspent_result_entry
        self.utxo_spend_info = utxo_spend_info
        
        

    
    def __str__(self):
        return "TotalUtxoInfo(list_unspent_result_entry={}, utxo_spend_info={})".format(self.list_unspent_result_entry, self.utxo_spend_info)
    def __eq__(self, other):
        if self.list_unspent_result_entry != other.list_unspent_result_entry:
            return False
        if self.utxo_spend_info != other.utxo_spend_info:
            return False
        return True

class _UniffiFfiConverterTypeTotalUtxoInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TotalUtxoInfo(
            list_unspent_result_entry=_UniffiFfiConverterTypeListUnspentResultEntry.read(buf),
            utxo_spend_info=_UniffiFfiConverterTypeUtxoSpendInfo.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterTypeListUnspentResultEntry.check_lower(value.list_unspent_result_entry)
        _UniffiFfiConverterTypeUtxoSpendInfo.check_lower(value.utxo_spend_info)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterTypeListUnspentResultEntry.write(value.list_unspent_result_entry, buf)
        _UniffiFfiConverterTypeUtxoSpendInfo.write(value.utxo_spend_info, buf)






class TakerBehavior(enum.Enum):
    
    NORMAL = 0
    
    DROP_CONNECTION_AFTER_FULL_SETUP = 1
    
    BROADCAST_CONTRACT_AFTER_FULL_SETUP = 2
    


class _UniffiFfiConverterTypeTakerBehavior(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TakerBehavior.NORMAL
        if variant == 2:
            return TakerBehavior.DROP_CONNECTION_AFTER_FULL_SETUP
        if variant == 3:
            return TakerBehavior.BROADCAST_CONTRACT_AFTER_FULL_SETUP
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == TakerBehavior.NORMAL:
            return
        if value == TakerBehavior.DROP_CONNECTION_AFTER_FULL_SETUP:
            return
        if value == TakerBehavior.BROADCAST_CONTRACT_AFTER_FULL_SETUP:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == TakerBehavior.NORMAL:
            buf.write_i32(1)
        if value == TakerBehavior.DROP_CONNECTION_AFTER_FULL_SETUP:
            buf.write_i32(2)
        if value == TakerBehavior.BROADCAST_CONTRACT_AFTER_FULL_SETUP:
            buf.write_i32(3)





# TakerError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class TakerError(Exception):
    pass

_UniffiTempTakerError = TakerError

class TakerError:  # type: ignore
    
    class Wallet(_UniffiTempTakerError):
        
        def __init__(self, msg):
            super().__init__(", ".join([
                "msg={!r}".format(msg),
            ]))
            self.msg = msg

        def __repr__(self):
            return "TakerError.Wallet({})".format(str(self))
    _UniffiTempTakerError.Wallet = Wallet # type: ignore
    class Protocol(_UniffiTempTakerError):
        
        def __init__(self, msg):
            super().__init__(", ".join([
                "msg={!r}".format(msg),
            ]))
            self.msg = msg

        def __repr__(self):
            return "TakerError.Protocol({})".format(str(self))
    _UniffiTempTakerError.Protocol = Protocol # type: ignore
    class Network(_UniffiTempTakerError):
        
        def __init__(self, msg):
            super().__init__(", ".join([
                "msg={!r}".format(msg),
            ]))
            self.msg = msg

        def __repr__(self):
            return "TakerError.Network({})".format(str(self))
    _UniffiTempTakerError.Network = Network # type: ignore
    class General(_UniffiTempTakerError):
        
        def __init__(self, msg):
            super().__init__(", ".join([
                "msg={!r}".format(msg),
            ]))
            self.msg = msg

        def __repr__(self):
            return "TakerError.General({})".format(str(self))
    _UniffiTempTakerError.General = General # type: ignore
    class Io(_UniffiTempTakerError):
        
        def __init__(self, msg):
            super().__init__(", ".join([
                "msg={!r}".format(msg),
            ]))
            self.msg = msg

        def __repr__(self):
            return "TakerError.Io({})".format(str(self))
    _UniffiTempTakerError.Io = Io # type: ignore

TakerError = _UniffiTempTakerError # type: ignore
del _UniffiTempTakerError


class _UniffiFfiConverterTypeTakerError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TakerError.Wallet(
                _UniffiFfiConverterString.read(buf),
            )
        if variant == 2:
            return TakerError.Protocol(
                _UniffiFfiConverterString.read(buf),
            )
        if variant == 3:
            return TakerError.Network(
                _UniffiFfiConverterString.read(buf),
            )
        if variant == 4:
            return TakerError.General(
                _UniffiFfiConverterString.read(buf),
            )
        if variant == 5:
            return TakerError.Io(
                _UniffiFfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, TakerError.Wallet):
            _UniffiFfiConverterString.check_lower(value.msg)
            return
        if isinstance(value, TakerError.Protocol):
            _UniffiFfiConverterString.check_lower(value.msg)
            return
        if isinstance(value, TakerError.Network):
            _UniffiFfiConverterString.check_lower(value.msg)
            return
        if isinstance(value, TakerError.General):
            _UniffiFfiConverterString.check_lower(value.msg)
            return
        if isinstance(value, TakerError.Io):
            _UniffiFfiConverterString.check_lower(value.msg)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, TakerError.Wallet):
            buf.write_i32(1)
            _UniffiFfiConverterString.write(value.msg, buf)
        if isinstance(value, TakerError.Protocol):
            buf.write_i32(2)
            _UniffiFfiConverterString.write(value.msg, buf)
        if isinstance(value, TakerError.Network):
            buf.write_i32(3)
            _UniffiFfiConverterString.write(value.msg, buf)
        if isinstance(value, TakerError.General):
            buf.write_i32(4)
            _UniffiFfiConverterString.write(value.msg, buf)
        if isinstance(value, TakerError.Io):
            buf.write_i32(5)
            _UniffiFfiConverterString.write(value.msg, buf)

class _UniffiFfiConverterOptionalTypeSwapReport(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeSwapReport.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeSwapReport.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeSwapReport.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterSequenceTypeAddress(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeAddress.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeAddress.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeAddress.read(buf) for i in range(count)
        ]

class _UniffiFfiConverterSequenceTypeListTransactionResult(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeListTransactionResult.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeListTransactionResult.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeListTransactionResult.read(buf) for i in range(count)
        ]

class _UniffiFfiConverterSequenceTypeTotalUtxoInfo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeTotalUtxoInfo.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeTotalUtxoInfo.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeTotalUtxoInfo.read(buf) for i in range(count)
        ]

class _UniffiFfiConverterOptionalFloat64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterFloat64.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterFloat64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterFloat64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class TakerProtocol(typing.Protocol):
    
    def backup(self, destination_path: str,password: typing.Optional[str]) -> None:
        raise NotImplementedError
    def display_offer(self, maker_offer: Offer) -> str:
        raise NotImplementedError
    def do_coinswap(self, swap_params: SwapParams) -> typing.Optional[SwapReport]:
        raise NotImplementedError
    def fetch_all_makers(self, ) -> typing.List[str]:
        raise NotImplementedError
    def fetch_offers(self, ) -> OfferBook:
        raise NotImplementedError
    def get_balances(self, ) -> Balances:
        raise NotImplementedError
    def get_next_external_address(self, address_type: AddressType) -> Address:
        raise NotImplementedError
    def get_next_internal_addresses(self, count: int,address_type: AddressType) -> typing.List[Address]:
        raise NotImplementedError
    def get_transactions(self, count: typing.Optional[int],skip: typing.Optional[int]) -> typing.List[ListTransactionResult]:
        raise NotImplementedError
    def get_wallet_name(self, ) -> str:
        raise NotImplementedError
    def is_offerbook_syncing(self, ) -> bool:
        raise NotImplementedError
    def list_all_utxo_spend_info(self, ) -> typing.List[TotalUtxoInfo]:
        raise NotImplementedError
    def lock_unspendable_utxos(self, ) -> None:
        raise NotImplementedError
    def recover_from_swap(self, ) -> None:
        raise NotImplementedError
    def run_offer_sync_now(self, ) -> None:
        raise NotImplementedError
    def send_to_address(self, address: str,amount: int,fee_rate: typing.Optional[float],manually_selected_outpoints: typing.Optional[typing.List[OutPoint]]) -> Txid:
        raise NotImplementedError
    def setup_logging(self, data_dir: typing.Optional[str],log_level: str) -> None:
        raise NotImplementedError
    def sync_and_save(self, ) -> None:
        raise NotImplementedError

class Taker(TakerProtocol):
    
    _handle: ctypes.c_uint64
    @classmethod
    def init(cls, data_dir: typing.Optional[str],wallet_file_name: typing.Optional[str],rpc_config: typing.Optional[RpcConfig],control_port: typing.Optional[int],tor_auth_password: typing.Optional[str],zmq_addr: str,password: typing.Optional[str]) -> Taker:
        
        _UniffiFfiConverterOptionalString.check_lower(data_dir)
        
        _UniffiFfiConverterOptionalString.check_lower(wallet_file_name)
        
        _UniffiFfiConverterOptionalTypeRPCConfig.check_lower(rpc_config)
        
        _UniffiFfiConverterOptionalUInt16.check_lower(control_port)
        
        _UniffiFfiConverterOptionalString.check_lower(tor_auth_password)
        
        _UniffiFfiConverterString.check_lower(zmq_addr)
        
        _UniffiFfiConverterOptionalString.check_lower(password)
        _uniffi_lowered_args = (
            _UniffiFfiConverterOptionalString.lower(data_dir),
            _UniffiFfiConverterOptionalString.lower(wallet_file_name),
            _UniffiFfiConverterOptionalTypeRPCConfig.lower(rpc_config),
            _UniffiFfiConverterOptionalUInt16.lower(control_port),
            _UniffiFfiConverterOptionalString.lower(tor_auth_password),
            _UniffiFfiConverterString.lower(zmq_addr),
            _UniffiFfiConverterOptionalString.lower(password),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeTaker.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_constructor_taker_init,
            *_uniffi_lowered_args,
        )
        return cls._uniffi_make_instance(_uniffi_ffi_result)
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        handle = getattr(self, "_handle", None)
        if handle is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_coinswap_ffi_fn_free_taker, handle)

    def _uniffi_clone_handle(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_coinswap_ffi_fn_clone_taker, self._handle)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _uniffi_make_instance(cls, handle):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required handle.
        inst = cls.__new__(cls)
        inst._handle = handle
        return inst
    def backup(self, destination_path: str,password: typing.Optional[str]) -> None:
        
        _UniffiFfiConverterString.check_lower(destination_path)
        
        _UniffiFfiConverterOptionalString.check_lower(password)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(destination_path),
            _UniffiFfiConverterOptionalString.lower(password),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taker_backup,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def display_offer(self, maker_offer: Offer) -> str:
        
        _UniffiFfiConverterTypeOffer.check_lower(maker_offer)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeOffer.lower(maker_offer),
        )
        _uniffi_lift_return = _UniffiFfiConverterString.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taker_display_offer,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def do_coinswap(self, swap_params: SwapParams) -> typing.Optional[SwapReport]:
        
        _UniffiFfiConverterTypeSwapParams.check_lower(swap_params)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeSwapParams.lower(swap_params),
        )
        _uniffi_lift_return = _UniffiFfiConverterOptionalTypeSwapReport.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taker_do_coinswap,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def fetch_all_makers(self, ) -> typing.List[str]:
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = _UniffiFfiConverterSequenceString.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taker_fetch_all_makers,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def fetch_offers(self, ) -> OfferBook:
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeOfferBook.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taker_fetch_offers,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def get_balances(self, ) -> Balances:
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeBalances.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taker_get_balances,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def get_next_external_address(self, address_type: AddressType) -> Address:
        
        _UniffiFfiConverterTypeAddressType.check_lower(address_type)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeAddressType.lower(address_type),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeAddress.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taker_get_next_external_address,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def get_next_internal_addresses(self, count: int,address_type: AddressType) -> typing.List[Address]:
        
        _UniffiFfiConverterUInt32.check_lower(count)
        
        _UniffiFfiConverterTypeAddressType.check_lower(address_type)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterUInt32.lower(count),
            _UniffiFfiConverterTypeAddressType.lower(address_type),
        )
        _uniffi_lift_return = _UniffiFfiConverterSequenceTypeAddress.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taker_get_next_internal_addresses,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def get_transactions(self, count: typing.Optional[int],skip: typing.Optional[int]) -> typing.List[ListTransactionResult]:
        
        _UniffiFfiConverterOptionalUInt32.check_lower(count)
        
        _UniffiFfiConverterOptionalUInt32.check_lower(skip)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterOptionalUInt32.lower(count),
            _UniffiFfiConverterOptionalUInt32.lower(skip),
        )
        _uniffi_lift_return = _UniffiFfiConverterSequenceTypeListTransactionResult.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taker_get_transactions,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def get_wallet_name(self, ) -> str:
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = _UniffiFfiConverterString.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taker_get_wallet_name,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def is_offerbook_syncing(self, ) -> bool:
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = _UniffiFfiConverterBoolean.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taker_is_offerbook_syncing,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def list_all_utxo_spend_info(self, ) -> typing.List[TotalUtxoInfo]:
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = _UniffiFfiConverterSequenceTypeTotalUtxoInfo.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taker_list_all_utxo_spend_info,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def lock_unspendable_utxos(self, ) -> None:
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taker_lock_unspendable_utxos,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def recover_from_swap(self, ) -> None:
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taker_recover_from_swap,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def run_offer_sync_now(self, ) -> None:
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taker_run_offer_sync_now,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def send_to_address(self, address: str,amount: int,fee_rate: typing.Optional[float],manually_selected_outpoints: typing.Optional[typing.List[OutPoint]]) -> Txid:
        
        _UniffiFfiConverterString.check_lower(address)
        
        _UniffiFfiConverterInt64.check_lower(amount)
        
        _UniffiFfiConverterOptionalFloat64.check_lower(fee_rate)
        
        _UniffiFfiConverterOptionalSequenceTypeOutPoint.check_lower(manually_selected_outpoints)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(address),
            _UniffiFfiConverterInt64.lower(amount),
            _UniffiFfiConverterOptionalFloat64.lower(fee_rate),
            _UniffiFfiConverterOptionalSequenceTypeOutPoint.lower(manually_selected_outpoints),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeTxid.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taker_send_to_address,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def setup_logging(self, data_dir: typing.Optional[str],log_level: str) -> None:
        
        _UniffiFfiConverterOptionalString.check_lower(data_dir)
        
        _UniffiFfiConverterString.check_lower(log_level)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterOptionalString.lower(data_dir),
            _UniffiFfiConverterString.lower(log_level),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taker_setup_logging,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def sync_and_save(self, ) -> None:
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taker_sync_and_save,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)





class _UniffiFfiConverterTypeTaker:
    @staticmethod
    def lift(value: int) -> Taker:
        return Taker._uniffi_make_instance(value)

    @staticmethod
    def check_lower(value: Taker):
        if not isinstance(value, Taker):
            raise TypeError("Expected Taker instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Taker) -> ctypes.c_uint64:
        return value._uniffi_clone_handle()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer) -> Taker:
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw handle value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Taker, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))


class TaprootTakerProtocol(typing.Protocol):
    
    def backup(self, destination_path: str,password: typing.Optional[str]) -> None:
        raise NotImplementedError
    def display_offer(self, maker_offer: Offer) -> str:
        raise NotImplementedError
    def do_coinswap(self, swap_params: TaprootSwapParams) -> typing.Optional[SwapReport]:
        raise NotImplementedError
    def fetch_all_makers(self, ) -> typing.List[str]:
        raise NotImplementedError
    def fetch_offers(self, ) -> OfferBook:
        raise NotImplementedError
    def get_balances(self, ) -> Balances:
        raise NotImplementedError
    def get_next_external_address(self, address_type: AddressType) -> Address:
        raise NotImplementedError
    def get_next_internal_addresses(self, count: int,address_type: AddressType) -> typing.List[Address]:
        raise NotImplementedError
    def get_transactions(self, count: typing.Optional[int],skip: typing.Optional[int]) -> typing.List[ListTransactionResult]:
        raise NotImplementedError
    def get_wallet_name(self, ) -> str:
        raise NotImplementedError
    def is_offerbook_syncing(self, ) -> bool:
        raise NotImplementedError
    def list_all_utxo_spend_info(self, ) -> typing.List[TotalUtxoInfo]:
        raise NotImplementedError
    def lock_unspendable_utxos(self, ) -> None:
        raise NotImplementedError
    def recover_from_swap(self, ) -> None:
        raise NotImplementedError
    def run_offer_sync_now(self, ) -> None:
        raise NotImplementedError
    def send_to_address(self, address: str,amount: int,fee_rate: typing.Optional[float],manually_selected_outpoints: typing.Optional[typing.List[OutPoint]]) -> str:
        raise NotImplementedError
    def setup_logging(self, data_dir: typing.Optional[str],log_level: str) -> None:
        raise NotImplementedError
    def sync_and_save(self, ) -> None:
        raise NotImplementedError

class TaprootTaker(TaprootTakerProtocol):
    
    _handle: ctypes.c_uint64
    @classmethod
    def init(cls, data_dir: typing.Optional[str],wallet_file_name: typing.Optional[str],rpc_config: typing.Optional[RpcConfig],control_port: typing.Optional[int],tor_auth_password: typing.Optional[str],zmq_addr: str,password: typing.Optional[str]) -> TaprootTaker:
        
        _UniffiFfiConverterOptionalString.check_lower(data_dir)
        
        _UniffiFfiConverterOptionalString.check_lower(wallet_file_name)
        
        _UniffiFfiConverterOptionalTypeRPCConfig.check_lower(rpc_config)
        
        _UniffiFfiConverterOptionalUInt16.check_lower(control_port)
        
        _UniffiFfiConverterOptionalString.check_lower(tor_auth_password)
        
        _UniffiFfiConverterString.check_lower(zmq_addr)
        
        _UniffiFfiConverterOptionalString.check_lower(password)
        _uniffi_lowered_args = (
            _UniffiFfiConverterOptionalString.lower(data_dir),
            _UniffiFfiConverterOptionalString.lower(wallet_file_name),
            _UniffiFfiConverterOptionalTypeRPCConfig.lower(rpc_config),
            _UniffiFfiConverterOptionalUInt16.lower(control_port),
            _UniffiFfiConverterOptionalString.lower(tor_auth_password),
            _UniffiFfiConverterString.lower(zmq_addr),
            _UniffiFfiConverterOptionalString.lower(password),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeTaprootTaker.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_constructor_taproottaker_init,
            *_uniffi_lowered_args,
        )
        return cls._uniffi_make_instance(_uniffi_ffi_result)
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        handle = getattr(self, "_handle", None)
        if handle is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_coinswap_ffi_fn_free_taproottaker, handle)

    def _uniffi_clone_handle(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_coinswap_ffi_fn_clone_taproottaker, self._handle)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _uniffi_make_instance(cls, handle):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required handle.
        inst = cls.__new__(cls)
        inst._handle = handle
        return inst
    def backup(self, destination_path: str,password: typing.Optional[str]) -> None:
        
        _UniffiFfiConverterString.check_lower(destination_path)
        
        _UniffiFfiConverterOptionalString.check_lower(password)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(destination_path),
            _UniffiFfiConverterOptionalString.lower(password),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_backup,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def display_offer(self, maker_offer: Offer) -> str:
        
        _UniffiFfiConverterTypeOffer.check_lower(maker_offer)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeOffer.lower(maker_offer),
        )
        _uniffi_lift_return = _UniffiFfiConverterString.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_display_offer,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def do_coinswap(self, swap_params: TaprootSwapParams) -> typing.Optional[SwapReport]:
        
        _UniffiFfiConverterTypeTaprootSwapParams.check_lower(swap_params)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeTaprootSwapParams.lower(swap_params),
        )
        _uniffi_lift_return = _UniffiFfiConverterOptionalTypeSwapReport.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_do_coinswap,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def fetch_all_makers(self, ) -> typing.List[str]:
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = _UniffiFfiConverterSequenceString.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_fetch_all_makers,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def fetch_offers(self, ) -> OfferBook:
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeOfferBook.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_fetch_offers,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def get_balances(self, ) -> Balances:
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeBalances.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_get_balances,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def get_next_external_address(self, address_type: AddressType) -> Address:
        
        _UniffiFfiConverterTypeAddressType.check_lower(address_type)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeAddressType.lower(address_type),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeAddress.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_get_next_external_address,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def get_next_internal_addresses(self, count: int,address_type: AddressType) -> typing.List[Address]:
        
        _UniffiFfiConverterUInt32.check_lower(count)
        
        _UniffiFfiConverterTypeAddressType.check_lower(address_type)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterUInt32.lower(count),
            _UniffiFfiConverterTypeAddressType.lower(address_type),
        )
        _uniffi_lift_return = _UniffiFfiConverterSequenceTypeAddress.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_get_next_internal_addresses,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def get_transactions(self, count: typing.Optional[int],skip: typing.Optional[int]) -> typing.List[ListTransactionResult]:
        
        _UniffiFfiConverterOptionalUInt32.check_lower(count)
        
        _UniffiFfiConverterOptionalUInt32.check_lower(skip)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterOptionalUInt32.lower(count),
            _UniffiFfiConverterOptionalUInt32.lower(skip),
        )
        _uniffi_lift_return = _UniffiFfiConverterSequenceTypeListTransactionResult.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_get_transactions,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def get_wallet_name(self, ) -> str:
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = _UniffiFfiConverterString.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_get_wallet_name,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def is_offerbook_syncing(self, ) -> bool:
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = _UniffiFfiConverterBoolean.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_is_offerbook_syncing,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def list_all_utxo_spend_info(self, ) -> typing.List[TotalUtxoInfo]:
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = _UniffiFfiConverterSequenceTypeTotalUtxoInfo.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_list_all_utxo_spend_info,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def lock_unspendable_utxos(self, ) -> None:
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_lock_unspendable_utxos,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def recover_from_swap(self, ) -> None:
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_recover_from_swap,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def run_offer_sync_now(self, ) -> None:
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_run_offer_sync_now,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def send_to_address(self, address: str,amount: int,fee_rate: typing.Optional[float],manually_selected_outpoints: typing.Optional[typing.List[OutPoint]]) -> str:
        
        _UniffiFfiConverterString.check_lower(address)
        
        _UniffiFfiConverterInt64.check_lower(amount)
        
        _UniffiFfiConverterOptionalFloat64.check_lower(fee_rate)
        
        _UniffiFfiConverterOptionalSequenceTypeOutPoint.check_lower(manually_selected_outpoints)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(address),
            _UniffiFfiConverterInt64.lower(amount),
            _UniffiFfiConverterOptionalFloat64.lower(fee_rate),
            _UniffiFfiConverterOptionalSequenceTypeOutPoint.lower(manually_selected_outpoints),
        )
        _uniffi_lift_return = _UniffiFfiConverterString.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_send_to_address,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def setup_logging(self, data_dir: typing.Optional[str],log_level: str) -> None:
        
        _UniffiFfiConverterOptionalString.check_lower(data_dir)
        
        _UniffiFfiConverterString.check_lower(log_level)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterOptionalString.lower(data_dir),
            _UniffiFfiConverterString.lower(log_level),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_setup_logging,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def sync_and_save(self, ) -> None:
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_coinswap_ffi_fn_method_taproottaker_sync_and_save,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)





class _UniffiFfiConverterTypeTaprootTaker:
    @staticmethod
    def lift(value: int) -> TaprootTaker:
        return TaprootTaker._uniffi_make_instance(value)

    @staticmethod
    def check_lower(value: TaprootTaker):
        if not isinstance(value, TaprootTaker):
            raise TypeError("Expected TaprootTaker instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: TaprootTaker) -> ctypes.c_uint64:
        return value._uniffi_clone_handle()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer) -> TaprootTaker:
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw handle value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: TaprootTaker, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))

class _UniffiFfiConverterOptionalTypeRPCConfig(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeRPCConfig.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeRPCConfig.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeRPCConfig.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterOptionalUInt16(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterUInt16.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterUInt16.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterUInt16.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")
def create_default_rpc_config() -> RpcConfig:
    _uniffi_lowered_args = (
    )
    _uniffi_lift_return = _UniffiFfiConverterTypeRPCConfig.lift
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_coinswap_ffi_fn_func_create_default_rpc_config,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def fetch_mempool_fees() -> FeeRates:
    _uniffi_lowered_args = (
    )
    _uniffi_lift_return = _UniffiFfiConverterTypeFeeRates.lift
    _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_coinswap_ffi_fn_func_fetch_mempool_fees,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def is_wallet_encrypted(wallet_path: str) -> bool:
    
    _UniffiFfiConverterString.check_lower(wallet_path)
    _uniffi_lowered_args = (
        _UniffiFfiConverterString.lower(wallet_path),
    )
    _uniffi_lift_return = _UniffiFfiConverterBoolean.lift
    _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_coinswap_ffi_fn_func_is_wallet_encrypted,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def restore_wallet_gui_app(data_dir: typing.Optional[str],wallet_file_name: typing.Optional[str],rpc_config: RpcConfig,backup_file_path: str,password: typing.Optional[str]) -> None:
    
    _UniffiFfiConverterOptionalString.check_lower(data_dir)
    
    _UniffiFfiConverterOptionalString.check_lower(wallet_file_name)
    
    _UniffiFfiConverterTypeRPCConfig.check_lower(rpc_config)
    
    _UniffiFfiConverterString.check_lower(backup_file_path)
    
    _UniffiFfiConverterOptionalString.check_lower(password)
    _uniffi_lowered_args = (
        _UniffiFfiConverterOptionalString.lower(data_dir),
        _UniffiFfiConverterOptionalString.lower(wallet_file_name),
        _UniffiFfiConverterTypeRPCConfig.lower(rpc_config),
        _UniffiFfiConverterString.lower(backup_file_path),
        _UniffiFfiConverterOptionalString.lower(password),
    )
    _uniffi_lift_return = lambda val: None
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_coinswap_ffi_fn_func_restore_wallet_gui_app,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def setup_logging(data_dir: typing.Optional[str]) -> None:
    
    _UniffiFfiConverterOptionalString.check_lower(data_dir)
    _uniffi_lowered_args = (
        _UniffiFfiConverterOptionalString.lower(data_dir),
    )
    _uniffi_lift_return = lambda val: None
    _uniffi_error_converter = _UniffiFfiConverterTypeTakerError
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_coinswap_ffi_fn_func_setup_logging,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)

__all__ = [
    "InternalError",
    "TakerBehavior",
    "TakerError",
    "Address",
    "AddressType",
    "Amount",
    "Balances",
    "FeeRates",
    "LockTime",
    "PublicKey",
    "FidelityBond",
    "FidelityProof",
    "SignedAmountSats",
    "GetTransactionResultDetail",
    "Txid",
    "WalletTxInfo",
    "ListTransactionResult",
    "ScriptBuf",
    "ListUnspentResultEntry",
    "MakerAddress",
    "MakerFeeInfo",
    "Offer",
    "MakerState",
    "MakerProtocol",
    "MakerOfferCandidate",
    "OfferBook",
    "OutPoint",
    "RpcConfig",
    "SwapParams",
    "UtxoWithAddress",
    "SwapReport",
    "TaprootSwapParams",
    "UtxoSpendInfo",
    "TotalUtxoInfo",
    "create_default_rpc_config",
    "fetch_mempool_fees",
    "is_wallet_encrypted",
    "restore_wallet_gui_app",
    "setup_logging",
    "Taker",
    "TakerProtocol",
    "TaprootTaker",
    "TaprootTakerProtocol",
]